/*
 * If not stated otherwise in this file or this component's Licenses.txt file the
 * following copyright and licenses apply:
 *
 * Copyright 2015 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**********************************************************************
   Copyright [2014] [Cisco Systems, Inc.]
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************/

/**********************************************************************

    MODULE: al_cert_api.c

        ASN.1 ANSC Code Generated by Cisco Systems, Inc.

    ---------------------------------------------------------------

    DESCRIPTION:

        This interface is for the ALCert implementation

        *   ALCertInitialize
        *   ALCertUnload
        *   ALCertAddTrustedCA
        *   ALCertAddSubject
        *   ALCertRemoveTrustedCA
        *   ALCertRemoveSubject
        *   ALCertAddCRL
        *   ALCertRemoveCRL
        *   ALCertGetCRLNextUpdateTime
        *   ALCertVerify
        *   ALCertAcquireCertInformation
        *   ALCertExtractCommonNameFromDN
        *   ALCertAcquireCertificationPath
        *   ALCertAcquireCertificateUnit
        *   ALCertAcquireCertificateUnitByHandle
        *   ALCertGetKeyTypeByHandle
        *   ALCertAcquireIDByHandle
        *   ALCertAcquireCANameByHandle
        *   ALCertAddPKIServer
        *   ALCertImportPKIServer
        *   ALCertRemovePKIServer
        *   ALCertRetrievePKIServerCert
        *   ALCertSignPKIClient
        *   ALCertCreateEntity
        *   ALCertCreatePKCS10CertificateRequest
        *   ALCertGetPrivateKeyInfo
        *   ALCertSetIssuedCertificate
        *   ALCertSetIssuedPKCS7CertChain
        *   ALCertMime64Encoding
        *   ALCertMime64Decoding
        *   ALCertIsKeyMatchable

    ---------------------------------------------------------------

    ENVIRONMENT:

        platform independent

    ---------------------------------------------------------------

    AUTHOR:

        Bin Zhu

    ---------------------------------------------------------------

    REVISION HISTORY:

        *   09/25/2002  initial revision
        *   12/20/03    add api to get the nextupdatetime of CRL
        *   08/06/04    add api "ALCertIsKeyMatchable" 
        *   09/08/04    check the subjectAltName in "ALCertAcquireCertInformation"

 **********************************************************************/

#include "ansc_pki_local.h"
#include "alcert_global.h"
#include "cw_vpn_sakm.h"
#include "cert_status.h"
#include "cert_attr_structure.h"
#include "cert_exported_api.h"
#include "alcert_internal.h"
#include "safec_lib_common.h"

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertInitialize
            (
                AL_HANDLE                   hUserContext
            );

    This routine is called by SAKM during initialization. It allocates
    memory block and contact certificates repository if necessary.

    argument:   AL_HANDLE               hUserContext
                Pointer to the memory block which contains all the
                information we need which was established during
                installation.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertInitialize
    (
        AL_HANDLE                   hUserContext
    )
{
    /***********************************************************
                    DEFINITION OF LOCAL VARIABLES
    ***********************************************************/

    /*
     * pointer to the registry structure filled by CERT user
     */
    PCERT_USER_CHARACTERISTICS  pUserChar = (PCERT_USER_CHARACTERISTICS)hUserContext;

    /*
     * pointer to the current PKI context
     */
    PALCERT_CONTEXT             pPKICertContext;

    /***********************************************************
                     PROCESS USER'S REGISTRATION
    ***********************************************************/

    /*
     * debug output
     */
    CERT_TRACE("AL_CERT: ALCertInitialize ...\n");

    /*
     * sanity check
     */
    if ( !hUserContext )
    {
        return  AL_STATUS_CERT_INVALID_HANDLE;
    }

    /*
     * allocate memory for holding our certificate context memory block
     */
    pPKICertContext = (PALCERT_CONTEXT)
        AnscCreateALCert(NULL, NULL);

    if ( !pPKICertContext )
    {
        return  AL_STATUS_CERT_RESOURCES;
    }

    /***********************************************************
      CONSTRUCT A STRONG RANDOM NUMBER GENERATOR FOR LATER USE
    ***********************************************************/

    /*
     * prepare to return, don't forget that we have to return the handle of certification context
     */
    pUserChar->hCertContext = (AL_HANDLE)pPKICertContext;

    return  AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertUnload
            (
                AL_HANDLE                   hCertContext
            )

    This routine is called by SAKM to clean and unload the certificate
    operation DLL.

    argument:   AL_HANDLE               hCertContext
                Pointer to the memory block which contains all the
                information we need to unload DLL.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertUnload
    (
        AL_HANDLE                   hCertContext
    )
{
    /***********************************************************
                    DEFINITION OF LOCAL VARIABLES
    ***********************************************************/

    /*
     * pointer to the current PKI client context
     */
    PALCERT_CONTEXT             pPKICertContext = (PALCERT_CONTEXT)hCertContext;

    /***********************************************************
                      CLEAN UP STATE AND UNLOAD
    ***********************************************************/

    /*
     * debug output
     */
    CERT_TRACE("AL_CERT: ALCertUnload ...\n");

    /*
     * sanity check
     */
    if ( !hCertContext )
    {
        return  AL_STATUS_CERT_INVALID_HANDLE;
    }

    pPKICertContext->Remove(pPKICertContext);

    return  AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertAddTrustedCA
            (
                AL_HANDLE                   hCertContext,
                PVOID                       pCertEncoding,
                ULONG                       ulEncodingSize,
                PAL_HANDLE                  phCertHandle
            )

    This routine is called by SAKM to add a new CA into the PKI client
    context. The input parameter will be the pointer to the raw binary
    data of X.509 self-signed certificate. We need to verify the
    content of certificate and the signature before we accept it.

    argument:   AL_HANDLE               hCertContext
                Pointer to the memory block returned from
                ALCertInitialize.

                PVOID                   pCertEncoding
                Pointer to the content buffer of certificate encoding.

                ULONG                   ulEncodingSize
                Size of the certificate encoding in octets.

                PAL_HANDLE              phCertHandle
                Receive the handle of the corresponding certificate.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAddTrustedCA
    (
        AL_HANDLE                   hCertContext,
        PVOID                       pCertEncoding,
        ULONG                       ulEncodingSize,
        PAL_HANDLE                  phCertHandle
    )
{
    /***********************************************************
                    DEFINITION OF LOCAL VARIABLES
    ***********************************************************/
    PALCERT_CONTEXT             pPKIContext     = (PALCERT_CONTEXT)hCertContext;
    AL_STATUS                   returnStatus    = AL_STATUS_SUCCESS;

    /*
     * pointer to the certificate for certification authority and certificate subject
     */
    PCA_ENTITY                  pEntity         = NULL;

    /*
     * debug output
     */
    CERT_TRACE("AL_CERT: ALCertAddTrustedCA ...\n");

    if( pPKIContext == NULL || pCertEncoding == NULL)
    {
        return  AL_STATUS_CERT_CERTIFICATE_UNAVAILABLE;
    }

    pEntity = (PCA_ENTITY)
        pPKIContext->AddTrustedCA
            (
                pPKIContext,
                "",
                pCertEncoding,
                ulEncodingSize
            );

    if( pEntity == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( phCertHandle != NULL)
    {
        *phCertHandle = (AL_HANDLE)pEntity;
    }

    return  returnStatus;
}
/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertAddSubject
            (
                AL_HANDLE                   hCertContext,
                PVOID                       pCertEncoding,
                ULONG                       ulEncodingSize,
                PVOID                       pPrivateKeyEncoding,
                ULONG                       ulKeyEncodingSize,
                PAL_HANDLE                  phCertHandle
            )

    This routine is called by SAKM to add a new subject into the PKI
    client context. The input parameter will be the pointer to the raw
    binary data of X.509 certificate. We need to verify the content of
    certificate and the signature before we accept it.

    argument:   AL_HANDLE               hCertContext
                Pointer to the memory block returned from
                ALCertInitialize.

                PVOID                   pCertEncoding
                Pointer to the content buffer of certificate encoding.

                ULONG                   ulEncodingSize
                Size of the certificate encoding in octets.

                PVOID                   pPrivateKeyEncoding
                Pointer to the DER encoding of subject's private key.

                ULONG                   ulKeyEncodingSize
                Size of the private key encoding buffer.

                PAL_HANDLE              phCertHandle
                Receive the handle of the corresponding certificate.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAddSubject
    (
        AL_HANDLE                   hCertContext,
        PVOID                       pCertEncoding,
        ULONG                       ulEncodingSize,
        PVOID                       pPrivateKeyEncoding,
        ULONG                       ulKeyEncodingSize,
        PAL_HANDLE                  phCertHandle
    )
{
    /***********************************************************
                    DEFINITION OF LOCAL VARIABLES
    ***********************************************************/
    PALCERT_CONTEXT             pPKIContext     = (PALCERT_CONTEXT)hCertContext;
    AL_STATUS                   returnStatus    = AL_STATUS_SUCCESS;
    PPKI_CLIENT_ENTITY          pEntity         = NULL;

    CERT_TRACE("AL_CERT: ALCertAddSubject...\n");

    if( pPKIContext == NULL || (PUCHAR)pCertEncoding == NULL || (PUCHAR)pPrivateKeyEncoding == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pEntity = (PPKI_CLIENT_ENTITY)
        pPKIContext->AddSubjectWithCert
            (
                pPKIContext,
                "",
                pCertEncoding,
                ulEncodingSize,
                pPrivateKeyEncoding,
                ulKeyEncodingSize
            );

    if( pEntity == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( phCertHandle != NULL)
    {
        *phCertHandle = (AL_HANDLE)pEntity;
    }

    return returnStatus;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertRemoveTrustedCA
            (
                AL_HANDLE                   hCertHandle
            )

    This routine is called by SAKM to remove an existing CA from the
    PKI client context.

    argument:   AL_HANDLE               hCertHandle
                Unique handle returned by ALCertAddTrustedCA.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertRemoveTrustedCA
    (
        AL_HANDLE                   hCertHandle
    )
{
    PCA_ENTITY                      pCA             = (PCA_ENTITY)hCertHandle;
    PALCERT_CONTEXT                 pPKIContext     = NULL;

    CERT_TRACE("AL_CERT: ALCertRemoveTrustedCA...\n");

    if( pCA == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pPKIContext = (PALCERT_CONTEXT)
        pCA->hContainerContext;

    if( pPKIContext == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS !=
            pPKIContext->RemoveCAEntity
                (
                    pPKIContext,
                    (ANSC_HANDLE)hCertHandle,
                    FALSE
                ))
    {
        return AL_STATUS_FAILURE;
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertRemoveSubject
            (
                AL_HANDLE                   hCertHandle
            )

    This routine is called by SAKM to remove an existing subject from
    the PKI client context.

    argument:   AL_HANDLE               hCertHandle
                Unique handle returned by ALCertAddSubject.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertRemoveSubject
    (
        AL_HANDLE                   hCertHandle
    )
{
    PPKI_CLIENT_ENTITY              pEntity         = (PPKI_CLIENT_ENTITY)hCertHandle;
    PALCERT_CONTEXT                 pPKIContext     = NULL;

    CERT_TRACE("AL_CERT: ALCertRemoveSubject...\n");

    if( hCertHandle == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pPKIContext = (PALCERT_CONTEXT)
        pEntity->hContainerContext;

    if( pPKIContext == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS !=
            pPKIContext->RemoveClientEntity
                (
                    pPKIContext,
                    hCertHandle
                ))
    {
        return AL_STATUS_FAILURE;
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertAddCRL
            (
                AL_HANDLE                   hCAHandle,
                PVOID                       pCRLEncoding,
                ULONG                       ulEncodingSize
            )

    This routine is called by SAKM to add a new CRL into the PKI client
    context.

    argument:   AL_HANDLE               hCAHandle
                Pointer to the memory block returned from
                ALCertAddTrustedCA.

                PVOID                   pCRLEncoding
                Pointer to the content buffer of CRL encoding.

                ULONG                   ulEncodingSize
                Size of the CRL encoding in octets.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAddCRL
    (
        AL_HANDLE                   hCAHandle,
        PVOID                       pCRLEncoding,
        ULONG                       ulEncodingSize
    )
{
    PCA_ENTITY                      pEntity  = (PCA_ENTITY)hCAHandle;

    CERT_TRACE("AL_CERT: ALCertAddCRL...\n");

    if( hCAHandle == NULL || pCRLEncoding == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS != 
           pEntity->SetCRLHandle(pEntity, pCRLEncoding, ulEncodingSize))
    {
        return AL_STATUS_FAILURE;
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertRemoveCRL
            (
                AL_HANDLE                   hCAHandle
            )

    This routine is called by SAKM to remove the current CRL from PKI client
    context.

    argument:   AL_HANDLE               hCAHandle
                Pointer to the memory block returned from
                ALCertAddTrustedCA.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertRemoveCRL
    (
        AL_HANDLE                   hCAHandle
    )
{
    PCA_ENTITY                      pEntity  = (PCA_ENTITY)hCAHandle;

    CERT_TRACE("AL_CERT: ALCertRemoveCRL...\n");

    if( hCAHandle == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS !=
          pEntity->RemoveCRL(pEntity))
    {
        return AL_STATUS_FAILURE;
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertGetCRLNextUpdateTime
            (
                AL_HANDLE                   hCAHandle,
                ANSC_HANDLE                 hTime   
            )

    This routine is called by SAKM to get the nextUpdateTime of CRL
    context.

    argument:   AL_HANDLE               hCAHandle
                Pointer to the memory block returned from
                ALCertAddTrustedCA.

                ANSC_HANDLE                 hTime   
                output time: PANSC_UNIVERSAL_TIME

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertGetCRLNextUpdateTime
    (
        AL_HANDLE                   hCAHandle,
        ANSC_HANDLE                 hTime       /* PANSC_UNIVERSAL_TIME */
    )
{
    PCA_ENTITY                      pEntity     = (PCA_ENTITY)hCAHandle;
    PANSC_ASN1_TIME                 pTimeObj    = NULL;
    PANSC_ASN1_ALTIME               pALTime     = NULL;
    PANSC_UNIVERSAL_TIME            pUniTime    = (PANSC_UNIVERSAL_TIME)hTime;
    ULONG                           year, month, day, hour, minute, second;
    PANSC_ASN1_CRL                  pCRL;

    CERT_TRACE("AL_CERT: ALCertRemoveCRL...\n");

    if( hCAHandle == NULL || pEntity->hCRLHandle == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pCRL = (PANSC_ASN1_CRL)pEntity->hCRLHandle;

    pTimeObj = (PANSC_ASN1_TIME)pCRL->GetNextUpdateTime(pCRL);

    if( pTimeObj == NULL || pTimeObj->bOptional)
    {
        return AL_STATUS_FAILURE;
    }

    pALTime  = (PANSC_ASN1_ALTIME)pTimeObj->GetSelection(pTimeObj);

    pALTime->GetTimeValue
        (
            pALTime,
            &year,
            &month,
            &day,
            &hour,
            &minute,
            &second
        );

    pUniTime->Year              = (USHORT)year;
    pUniTime->Month             = (USHORT)month;
    pUniTime->DayOfMonth        = (USHORT)day;
    pUniTime->Hour              = (USHORT)hour;
    pUniTime->Minute            = (USHORT)minute;
    pUniTime->Second            = (USHORT)second;

    return AL_STATUS_SUCCESS;
}

/***********************************************************
           CERTIFICATE VERIFICATION API FUNCTIONS
***********************************************************/
/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
        ALCertVerify
            (
                AL_HANDLE                   hCertContext,
                ULONG                       ulCertPathLength,
                PVOID*                      pCertArray,
                PULONG                      pulCertSizeArray,
                PIKE_COMMON_ID              pSubjectID
            )

    This routine is called by SAKM to verify the binding between an
    user and its public key.

    argument:   AL_HANDLE               hCertContext
                Unique handle returned by ALCertInitialize.

                ULONG                   ulCertPathLength
                Specify the number of certs contained in the cert array.

                PVOID*                  pCertArray
                Array of pointers that includes every certificate which
                is supposed to be on the certification path.

                PULONG                  pulCertSizeArray
                Array of size of the DER encoding certificate buffer.

                PIKE_COMMON_ID          pSubjectID
                Extract the subject distinguish name or general name
                from the certificate and copy it over to the ID.

                BOOLEAN                     bCheckId
                TRUE  -- check the id again the certificate's subject 
                         name or subjectAltName
                FALSE -- retrieve the subject name from the certificate
                         and construct the id with it.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertVerify
    (
        AL_HANDLE                   hCertContext,
        ULONG                       ulCertPathLength,
        PVOID*                      pCertArray,
        PULONG                      pulCertSizeArray,
        PIKE_COMMON_ID              pSubjectID,
        BOOLEAN                     bCheckId        /*= FALSE*/ /*BAKEOFF*/
    )
{
    PALCERT_CONTEXT                 pThisObject = (PALCERT_CONTEXT)hCertContext;
    ANSC_STATUS                     retStatus;

    CERT_TRACE("AL_CERT: ALCertVerify...ulCertPathLength = %lu\n",ulCertPathLength);

    if( hCertContext == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    retStatus = 
        pThisObject->VerifyCertChain
            (
                pThisObject,
                ulCertPathLength,
                pCertArray,
                pulCertSizeArray,
                pSubjectID,
                bCheckId,
                TRUE
            );

    if( retStatus != ANSC_STATUS_SUCCESS)
    {
        CERT_TRACE("AL_CERT: ALCertVerify Failed... 0x%lX\n", retStatus);

        return retStatus;
    }
    
    CERT_TRACE("AL_CERT: ALCertVerify Succeeded...\n");

    return AL_STATUS_SUCCESS;
}


/***********************************************************
             CERTIFICATE REQUEST API FUNCTIONS
***********************************************************/
/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertAcquireCertInformation
        (
            AL_HANDLE                   hCertContext,
            PAL_INTERNAL_PKI_INFO       pInternalPKIInfo
        )

    This routine is called by SAKM to retrieve certain information
    about a CA's certificate or subject's certificate.

    argument:   AL_HANDLE               hCertContext
                Unique handle returned by ALCertInitialize.

                PAL_INTERNAL_PKI_INFO   pInternalPKIInfo
                As input parameter, it includes the handle of a
                certificate or encoding content; as output parameter,
                it receives the description of issuer / subject.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAcquireCertInformation
    (
        AL_HANDLE                   hCertContext,
        PAL_INTERNAL_PKI_INFO       pInternalPKIInfo
    )
{
    UNREFERENCED_PARAMETER(hCertContext);
    PANSC_ASN1_CERTIFICATE          pCert;
    PANSC_ASN1_NAME                 pName;
    PANSC_ASN1_GENERALNAMES         pAltNames;
    PUCHAR                          pEncoding, pBack;
    ULONG                           length;
    UCHAR                           pValue[256]= { 0 };
    ULONG                           valueLen   = 256;
    errno_t                         rc         = -1;

    CERT_TRACE("AL_CERT: ALCertAcquireCertInformation...\n");

    if( pInternalPKIInfo == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    length    = pInternalPKIInfo->ulContentSize;
    pEncoding = pInternalPKIInfo->CertEncodingContent;
    pBack     = pEncoding;

    if(!AnscCheckAsn1Validity(pEncoding, length))
    {
        AnscTrace("Invalid ASN1 encoding.\n");

        return ANSC_ASN1_INVALID_ENCODE_LENGTH;
    }
    
    /* create the certificate and decode it */
    pCert = (PANSC_ASN1_CERTIFICATE)AnscAsn1CreateCertificate(NULL);

    if( pCert == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS != pCert->DecodingData(pCert, (PVOID*)&pBack))
    {
        pCert->AsnFree(pCert);

        return AL_STATUS_FAILURE;
    }

    /* verify it */
    if( ANSC_STATUS_SUCCESS != pCert->CheckValidity(pCert, TRUE))
    {
        pCert->AsnFree(pCert);

        return AL_STATUS_FAILURE;        
    }

    /* get the key type */
    if( pCert->GetKeyType(pCert) == PKI_RSA_KEY)
    {
        pInternalPKIInfo->KeyType = RSA_KEY;
    }
    else
    {
        pInternalPKIInfo->KeyType = DSA_KEY;
    }


    /* issuer name */
    pName = (PANSC_ASN1_NAME)pCert->GetIssuerHandle(pCert);

    if( pName != NULL)
    {
        /* get the country name */
        length = MAXIMUM_COUNTRY_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->IssuerCountryName,
                MAXIMUM_COUNTRY_NAME_SIZE
            );

        pName->GetNameByOID
            (
                pName,
                "2.5.4.6",
                pInternalPKIInfo->IssuerCountryName,
                &length
            );

        /* get the organ name */
        length = MAXIMUM_ORGANIZATION_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->IssuerOrganizationName,
                MAXIMUM_ORGANIZATION_NAME_SIZE
            );

        pName->GetNameByOID
            (
                pName,
                "2.5.4.10",
                pInternalPKIInfo->IssuerOrganizationName,
                &length
            );

        /* get ou name */
        length = MAXIMUM_OU_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->IssuerOUName,
                MAXIMUM_OU_NAME_SIZE
            );

        pName->GetNameByOID 
            (
                pName,
                "2.5.4.11",
                pInternalPKIInfo->IssuerOUName,
                &length
            );

        /* get common name */
        length = MAXIMUM_COMMON_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->IssuerCommonName,
                MAXIMUM_COMMON_NAME_SIZE
            );

        pName->GetNameByOID
            (
                pName,
                "2.5.4.3",
                pInternalPKIInfo->IssuerCommonName,
                &length
            );
    }

    /* subject name */
    pName = (PANSC_ASN1_NAME)pCert->GetSubjectHandle(pCert);

    if( pName != NULL)
    {
        /* get the country name */
        length = MAXIMUM_COUNTRY_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->SubjectCountryName,
                MAXIMUM_COUNTRY_NAME_SIZE
            );

        pName->GetNameByOID
            (
                pName,
                "2.5.4.6",
                pInternalPKIInfo->SubjectCountryName,
                &length
            );

        /* get the organ name */
        length = MAXIMUM_ORGANIZATION_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->SubjectOrganizationName,
                MAXIMUM_ORGANIZATION_NAME_SIZE
            );

        pName->GetNameByOID
            (
                pName,
                "2.5.4.10",
                pInternalPKIInfo->SubjectOrganizationName,
                &length
            );

        /* get ou name */
        length = MAXIMUM_OU_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->SubjectOUName,
                MAXIMUM_OU_NAME_SIZE
            );

        pName->GetNameByOID 
            (
                pName,
                "2.5.4.11",
                pInternalPKIInfo->SubjectOUName,
                &length
            );

        /* get common name */
        length = MAXIMUM_COMMON_NAME_SIZE; 
        AnscZeroMemory
            (
                pInternalPKIInfo->SubjectCommonName,
                MAXIMUM_COMMON_NAME_SIZE
            );

        pName->GetNameByOID
            (
                pName,
                "2.5.4.3",
                pInternalPKIInfo->SubjectCommonName,
                &length
            );
    }

    /*
     * check the subjectAltName 
     */
    if( TRUE )
    {
        pAltNames = (PANSC_ASN1_GENERALNAMES)
            pCert->GetSubjectAltName(pCert, TRUE);

        if( pAltNames != NULL)
        {
            /* check IP Address */
            valueLen   = 256;
            AnscZeroMemory(pValue, valueLen);
            if( pAltNames->GetAltNameByMask
                   (
                      pAltNames,
                      GENERALNAME_MASK_IPADDRESS,
                      pValue,
                      &valueLen
                   ) == ANSC_STATUS_SUCCESS)
            {
                rc = sprintf_s
                    (
                        pInternalPKIInfo->SubjectAltNameIP,
                        sizeof(pInternalPKIInfo->SubjectAltNameIP),
                        "%d.%d.%d.%d",
                        pValue[0],
                        pValue[1],
                        pValue[2],
                        pValue[3]
                    );
                if(rc < EOK)
                {
                    ERR_CHK(rc);
                }
            }

            /* check DNS Name */
            valueLen   = 256;
            AnscZeroMemory(pValue, valueLen);
            if( pAltNames->GetAltNameByMask
                   (
                      pAltNames,
                      GENERALNAME_MASK_DNSNAME,
                      pValue,
                      &valueLen
                   ) == ANSC_STATUS_SUCCESS)
            {
                AnscCopyMemory
                    (
                       pInternalPKIInfo->SubjectAltNameDNS,
                       pValue,
                       valueLen
                    );
            }

            /* check Email Name */
            valueLen   = 256;
            AnscZeroMemory(pValue, valueLen);
            if( pAltNames->GetAltNameByMask
                   (
                      pAltNames,
                      GENERALNAME_MASK_RFC822NAME,
                      pValue,
                      &valueLen
                   ) == ANSC_STATUS_SUCCESS)
            {
                AnscCopyMemory
                    (
                       pInternalPKIInfo->SubjectAltNameEmail,
                       pValue,
                       valueLen
                    );
            }
        }
    }
    /*
     *  fill in the expiration data.
     */
    pCert->GetExpirationTime(pCert, (ANSC_HANDLE)&pInternalPKIInfo->ExpirationTime);

    /*
     *  free the certificate handle;
     */
    pCert->AsnFree(pCert);

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertExtractCommonNameFromDN
        (
            PVOID                       pDNEncoding,
            ULONG                       ulEncodingSize,
            PCHAR                       pCommonNameString
        )

    This routine is called by SAKM to extract the subject's common name
    from the DN encoding data.

    argument:   PVOID                   pDNEncoding
                Pointer to the DER encoding data of the DN.

                ULONG                   ulEncodingSize
                Specify the size of the encoding data.

                PCHAR                   pCommonNameString
                Pointer to the output buffer which is going to the hold
                the string of common name.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertExtractCommonNameFromDN
    (
        PVOID                       pDNEncoding,
        ULONG                       ulEncodingSize,
        PCHAR                       pCommonNameString
    )
{
    /***********************************************************
                    DEFINITION OF LOCAL VARIABLES
    ***********************************************************/
    PANSC_ASN1_NAME                 pNameObject;
    PUCHAR                          pBack        = (PUCHAR)pDNEncoding;
    ULONG                           length       = 256;

    CERT_TRACE("AL_CERT: ALCertExtractCommonNameFromDN...\n");

    if( pDNEncoding == NULL || ulEncodingSize == 0 || pCommonNameString == NULL)
    {
        return AL_STATUS_FAILURE;
    }
    
    if(!AnscCheckAsn1Validity(pDNEncoding, ulEncodingSize))
    {
        AnscTrace("Invalid ASN1 encoding.\n");

        return ANSC_ASN1_INVALID_ENCODE_LENGTH;
    }

    /* create the name object and decode from encoding */
    pNameObject = (PANSC_ASN1_NAME)AnscAsn1CreateName(NULL);

    if( pNameObject == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS != pNameObject->DecodingData(pNameObject, (PVOID*)&pBack))
    {
        return AL_STATUS_FAILURE;
    }

    if( !pNameObject->GetCommonName(pNameObject, pCommonNameString, &length))
    {
        return AL_STATUS_FAILURE;
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertAcquireCertificationPath
        (
            AL_HANDLE                   hCertContext,
            UCHAR                       ucCertEncoding,
            PVOID                       pCertificateRequirement,
            ULONG                       ulRequirementSize,
            AL_INTERNAL_PKI_KEY_TYPE    KeyType,
            PAL_HANDLE                  phCertPathContext,
            PULONG                      pulCertNumber,
            BOOLEAN                     bIncludeRootCA
        )

    This routine is called by SAKM to acquire a complete certification
    path.

    argument:   AL_HANDLE               hCertContext
                Unique handle returned by ALCertInitialize.

                UCHAR                   ucCertEncoding
                Specify the encoding format which is defined in ISAKMP
                draft.

                PVOID                   pCertificateRequirement
                Specify the requirement for certification authority.

                ULONG                   ulRequirementSize
                Size of the encoding of the certification authority.

                AL_INTERNAL_PKI_KEY_TYPEKeyType,
                Specify the current PKI algorithm: DSA/RSA/DH.

                PAL_HANDLE              phCertPathContext
                Receive the temporary handle which is used to acquire
                every unit of the certification path.

                PULONG                  pulCertNumber
                Receive the number of units contained in the path.

                BOOLEAN                 bIncludeRootCA
                If TRUE, we should include root CA's certificate in the
                path as well, if any.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAcquireCertificationPath
    (
        AL_HANDLE                   hCertContext,
        UCHAR                       ucCertEncoding,
        PVOID                       pCertificateRequirement,
        ULONG                       ulRequirementSize,
        AL_INTERNAL_PKI_KEY_TYPE    KeyType,
        PAL_HANDLE                  phCertPathContext,
        PULONG                      pulCertNumber,
        BOOLEAN                     bIncludeRootCA
    )
{
    UNREFERENCED_PARAMETER(ucCertEncoding);
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hCertContext;
    PPKI_CLIENT_ENTITY              pEntity       = NULL;
    ULONG                           length;

    if( hCertContext == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    CERT_TRACE("\nAL_CERT: ALCertAcquireCertificationPath...\n");

    /*
     * we only support X.509 signature encoding for now ... but we don't do encoding checking anyway
     */
    if ( pCertificateRequirement && ulRequirementSize )
    {
        pEntity = (PPKI_CLIENT_ENTITY)
            pThisObject->LookforEntityWithIssuerName
                (
                    pThisObject,
                    (PUCHAR)pCertificateRequirement,
                    ulRequirementSize
                );
    }
    else
    {
        if( KeyType == RSA_KEY)
        {
            pEntity = (PPKI_CLIENT_ENTITY)
               pThisObject->LookforEntityWithKeyType
                    (
                        pThisObject,
                        PKI_RSA_KEY
                    );
        }
        else
        {
            pEntity = (PPKI_CLIENT_ENTITY)
               pThisObject->LookforEntityWithKeyType
                    (
                        pThisObject,
                        PKI_DSA_KEY
                    );
        }
    }

    if( pEntity == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( phCertPathContext != NULL)
    {
        *phCertPathContext = (AL_HANDLE)pEntity;
    }

    if( bIncludeRootCA)
    {
        length = 
            pThisObject->GetCertChainPath
                (
                    pThisObject,
                    pEntity
                );
    }
    else
    {
        length = 1;
    }

    if( pulCertNumber != NULL)
    {
        *pulCertNumber = length;
    }

    return AL_STATUS_SUCCESS;
}


/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertAcquireCertificateUnit
        (
            AL_HANDLE                   hCertPathContext,
            ULONG                       ulIndex,
            PUCHAR                      pucCertEncoding,
            PVOID                       pCertUnit,
            PULONG                      pulCertUnitSize,
            PAL_HANDLE                  phCertHandle,
            BOOLEAN                     bIncludeRootCA
        )

    This routine is called by SAKM to acquire a piece certificate unit
    which is part of a complete certification path.

    argument:   AL_HANDLE               hCertPathContext
                Xuechen note: Unique handle returned by ALCertInitialize.
                It's probably not true here, it seems it's the handle of 
                cert path returned from the "AcquireCertificationPath"

                ULONG                   ulIndex
                Specify the index of the certificate unit. The first
                unit must be the self-signed CA's certificate; the last
                unit must be the subject's certificate.

                PUCHAR                  pucCertEncoding
                Receive the encoding format which is defined in ISAKMP
                draft.

                PVOID                   pCertUnit
                Receive the DER encoding content of the certificate.

                PULONG                  pulCertUnitSize
                Receive the size of the encoding content.

                PAL_HANDLE              phCertHandle
                Receive the handle of the subject's certificate. We're
                going to use it later.

                BOOLEAN                 bIncludeRootCA
                If TRUE, we should include root CA's certificate in the
                path as well, if any.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAcquireCertificateUnit
    (
        AL_HANDLE                   hCertPathContext,
        ULONG                       ulIndex,
        PUCHAR                      pucCertEncoding,
        PVOID                       pCertUnit,
        PULONG                      pulCertUnitSize,
        PAL_HANDLE                  phCertHandle,
        BOOLEAN                     bIncludeRootCA
    )
{
    PPKI_CLIENT_ENTITY              pEntity         = (PPKI_CLIENT_ENTITY)hCertPathContext;
    PALCERT_CONTEXT                 pThisObject     = NULL;
    ULONG                           ulCertNumber    = 0;
    BOOLEAN                         bIsCA           = FALSE;
    PCA_ENTITY                      pCA;

    CERT_TRACE("AL_CERT: ALCertAcquireCertificateUnit ...\n");

    if( hCertPathContext == NULL || pulCertUnitSize == NULL)
    {
        return  AL_STATUS_CERT_INVALID_HANDLE;
    }

    pThisObject = (PALCERT_CONTEXT)pEntity->hContainerContext;

    if( pThisObject == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if ( pucCertEncoding )
    {
        *pucCertEncoding = X509_SIG_ENCODING;
    }

    if ( phCertHandle ) /* caller could pass NULL, which means he doesn't want the handle */
    {
        *phCertHandle = (AL_HANDLE)pEntity;
    }

    ulCertNumber = pThisObject->GetCertChainPath(pThisObject, pEntity);

    if( bIncludeRootCA)
    {
        if( ulCertNumber == 0 || ulIndex >= ulCertNumber)
        {
            return AL_STATUS_FAILURE;
        }

        if( ulIndex != ulCertNumber - 1)
        {
            bIsCA = TRUE;
        }
    }

    /* ready for output */
    if( bIsCA)
    {
        pCA = (PCA_ENTITY)pThisObject->LookforCAInPath
                (
                    pThisObject,
                    pEntity,
                    ulCertNumber - ulIndex - 1
                );

        if( pCA == NULL)
        {
            return AL_STATUS_FAILURE;
        }

        if( pCA->uLength >= *pulCertUnitSize)
        {
            *pulCertUnitSize = pCA->uLength;

            return  AL_STATUS_CERT_INVALID_LENGTH;
        }
        else
        {
            *pulCertUnitSize = pCA->uLength;

            if(pCertUnit != NULL)
            {
                AnscCopyMemory
                    (
                        pCertUnit,
                        pCA->pCertEncoding,
                        pCA->uLength
                    );
            }
        }
    }
    else
    {
        if( pEntity->uLength >= *pulCertUnitSize)
        {
            *pulCertUnitSize = pEntity->uLength;

            return  AL_STATUS_CERT_INVALID_LENGTH;
        }
        else
        {
            *pulCertUnitSize = pEntity->uLength;
            if(pCertUnit != NULL)
            {
                AnscCopyMemory
                    (
                        pCertUnit,
                        pEntity->pCertEncoding,
                        pEntity->uLength
                    );
            }
        }
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertAcquireCertificateUnitByHandle
        (
            AL_HANDLE                   hCertHandle,
            PUCHAR                      pucCertEncoding,
            PVOID                       pCertUnit,
            PULONG                      pulCertUnitSize
        )

    This routine is called by SAKM to acquire a piece certificate unit
    which is part of a complete certification path.

    argument:   AL_HANDLE               hCertHandle
                Returned from ALCertAcquireCertificateUnit.

                PUCHAR                  pucCertEncoding
                Receive the encoding format which is defined in ISAKMP
                draft.

                PVOID                   pCertUnit
                Receive the DER encoding content of the certificate.

                PULONG                  pulCertUnitSize
                Receive the size of the encoding content.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAcquireCertificateUnitByHandle
    (
        AL_HANDLE                   hCertHandle,
        PUCHAR                      pucCertEncoding,
        PVOID                       pCertUnit,
        PULONG                      pulCertUnitSize
    )
{
    PPKI_CLIENT_ENTITY              pThisObject = (PPKI_CLIENT_ENTITY)hCertHandle;

    CERT_TRACE("AL_CERT: ALCertAcquireCertificateUnitByHandle...\n");

    if( hCertHandle == NULL || pCertUnit == NULL || pulCertUnitSize == NULL )
    {
        return AL_STATUS_FAILURE;
    }

    if(pucCertEncoding != NULL)
    {
        *pucCertEncoding = X509_SIG_ENCODING;
    }

    if( pThisObject->pCertEncoding == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( *pulCertUnitSize < pThisObject->uLength)
    {
        *pulCertUnitSize = pThisObject->uLength;

        return AL_STATUS_CERT_INVALID_LENGTH;
    }

    *pulCertUnitSize = pThisObject->uLength;

    AnscCopyMemory
        (
            (PVOID)pCertUnit,
            pThisObject->pCertEncoding,
            pThisObject->uLength
        );

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertGetKeyTypeByHandle
        (
            AL_HANDLE                   hCertHandle,
            PAL_INTERNAL_PKI_KEY_TYPE   pKeyType
        )

    This routine is called by SAKM to get the key type information about
    the current subject.

    argument:   AL_HANDLE                   hCertHandle
                Returned from ALCertAcquireCertificateUnit.

                PAL_INTERNAL_PKI_KEY_TYPE   pKeyType
                Receive the key type information of the subject.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertGetKeyTypeByHandle
    (
        AL_HANDLE                   hCertHandle,
        PAL_INTERNAL_PKI_KEY_TYPE   pKeyType
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hCertHandle;
    PKI_KEY_TYPE                    keyType;

    if( hCertHandle == NULL || pKeyType == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    keyType = pThisObject->GetKeyType(pThisObject);

    if( keyType == PKI_RSA_KEY)
    {
        *pKeyType =  RSA_KEY;

    }
    else if( keyType == PKI_DSA_KEY)
    {
        *pKeyType =  DSA_KEY;
    }
    else
    {
        return AL_STATUS_FAILURE;
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertGetKeyTypeByHandle
        (
            AL_HANDLE                   hCertHandle,
            PAL_INTERNAL_PKI_KEY_TYPE   pKeyType
        )

    This routine is called by SAKM to get the key type information about
    the current subject.

    argument:   AL_HANDLE                   hCertHandle
                Returned from ALCertAcquireCertificateUnit.

                PAL_INTERNAL_PKI_KEY_TYPE   pKeyType
                Receive the key type information of the subject.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAcquireIDByHandle
    (
        AL_HANDLE                   hCertHandle,
        PIKE_COMMON_ID              pSubjectID
    )
{
    PPKI_CLIENT_ENTITY              pEntity              = (PPKI_CLIENT_ENTITY)hCertHandle;
    PAL_INTERNAL_CERTIFICATE        pInternalCertificate = NULL;
    PAL_INTERNAL_PUBLIC_KEY         inPublicKey;
    PAL_INTERNAL_PRIVATE_KEY        inPrivateKey;
    PANSC_CRYPTO_PUB_KEY_GEN_PARAMS pKeyParam;
    PKI_KEY_TYPE                    keyType;
    PANSC_ASN1_CERTIFICATE          pCert;

    CERT_TRACE("AL_CERT: ALCertAcquireIDByHandle...\n");

    if( hCertHandle == NULL || pSubjectID == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pInternalCertificate = (PAL_INTERNAL_CERTIFICATE)
        pSubjectID->Attribute.hInternalCertificate;

    pKeyParam            = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
        pEntity->hKeyParam;

    if( pInternalCertificate == NULL || pKeyParam == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    /* get the key */
    inPublicKey = &pInternalCertificate->PublicKey;
    inPrivateKey = &pInternalCertificate->PrivateKey;
    keyType = pEntity->GetKeyType(pEntity);

    if( keyType == PKI_RSA_KEY)
    {
        pInternalCertificate->KeyType = RSA_KEY;
        inPublicKey->KeyType          = RSA_KEY;
        inPrivateKey->KeyType         = RSA_KEY;

        /* public key */
        AnscCopyMemory
            (
                &inPublicKey->Key.RSAPublicKey,
                &pKeyParam->PublicKey.RSA,
                sizeof(AL_CRYPTO_RSA_PUBLIC_KEY)
            );

        /* private key */
        AnscCopyMemory
            (
                &inPrivateKey->Key.RSAPrivateKey,
                &pKeyParam->PrivateKey.RSA,
                sizeof(AL_CRYPTO_RSA_PRIVATE_KEY)
            );

        /*
         *  DH  AL_CERT user requires keys in host order
         */
#if defined(_ANSC_LITTLE_ENDIAN_)
        AnscMemoryFromNToH((char*)inPublicKey->Key.RSAPublicKey.Modulus.Data,                  inPublicKey->Key.RSAPublicKey.Modulus.Length);
        AnscMemoryFromNToH((char*)inPublicKey->Key.RSAPublicKey.PublicExponent.Data.ucData,    inPublicKey->Key.RSAPublicKey.PublicExponent.Length);

        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.Modulus.Data,                inPrivateKey->Key.RSAPrivateKey.Modulus.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.PublicExponent.Data.ucData,  inPrivateKey->Key.RSAPrivateKey.PublicExponent.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.PrivateExponent.Data.ucData, inPrivateKey->Key.RSAPrivateKey.PrivateExponent.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.Prime1.Data,                 inPrivateKey->Key.RSAPrivateKey.Prime1.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.Prime2.Data,                 inPrivateKey->Key.RSAPrivateKey.Prime2.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.Exponent1.Data.ucData,       inPrivateKey->Key.RSAPrivateKey.Exponent1.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.Exponent2.Data.ucData,       inPrivateKey->Key.RSAPrivateKey.Exponent2.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.RSAPrivateKey.CoEfficient.Data.ucData,     inPrivateKey->Key.RSAPrivateKey.CoEfficient.Length);
#endif
    }
    else /* DSA */
    {
        pInternalCertificate->KeyType = DSA_KEY;
        inPublicKey->KeyType          = DSA_KEY;
        inPrivateKey->KeyType         = DSA_KEY;

        /* public key */
        AnscCopyMemory
            (
                &inPublicKey->Key.DSAPublicKey,
                &pKeyParam->PublicKey.DSA,
                sizeof(AL_CRYPTO_DSA_PUBLIC_KEY)
            );

        /* private key */
        AnscCopyMemory
            (
                &inPrivateKey->Key.DSAPrivateKey,
                &pKeyParam->PrivateKey.DSA,
                sizeof(AL_CRYPTO_DSA_PRIVATE_KEY)
            );

        /*
         *  DH  AL_CERT user requires keys in host order
         */
#if defined(_ANSC_LITTLE_ENDIAN_)
        AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamP.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamP.Length);
        AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamQ.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamQ.Length);
        AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamG.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamG.Length);
        AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamY.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamY.Length);

        AnscMemoryFromNToH((char*)inPrivateKey->Key.DSAPrivateKey.ParamP.Data.ucData,  inPrivateKey->Key.DSAPrivateKey.ParamP.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.DSAPrivateKey.ParamQ.Data.ucData,  inPrivateKey->Key.DSAPrivateKey.ParamQ.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.DSAPrivateKey.ParamG.Data.ucData,  inPrivateKey->Key.DSAPrivateKey.ParamG.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.DSAPrivateKey.ParamY.Data.ucData,  inPrivateKey->Key.DSAPrivateKey.ParamY.Length);
        AnscMemoryFromNToH((char*)inPrivateKey->Key.DSAPrivateKey.ParamX.Data.ucData,  inPrivateKey->Key.DSAPrivateKey.ParamX.Length);
#endif
    }

    pSubjectID->Attribute.AttributesMask |= CERTIFICATE_FLAG;

    /* get the certificate */
    pCert = (PANSC_ASN1_CERTIFICATE)pEntity->hUserCert;

    if( pCert != NULL)
    {
        if( ANSC_STATUS_SUCCESS !=
                RetrieveNameEncoding
                    (   
                        pCert,
                        pSubjectID
                    ))
        {
            return AL_STATUS_FAILURE;
        }
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    AL_CERT API FUNCTION

    AL_STATUS  AL_CERT_API
    ALCertAcquireCANameByHandle
        (
            AL_HANDLE                   hCertHandle,
            PUCHAR                      pucCertEncoding,
            PVOID                       pNameEncoding,
            PULONG                      pulNameEncodingSize
        )

    This routine is called by SAKM to acquire the CA's name encoding by
    matching the handle.

    argument:   AL_HANDLE               hCertHandle
                Returned from ALCertAddTrustedCA.

                PVOID                   pNameEncoding
                Receive the content of name encoding.

                PULONG                  pulNameEncodingSize
                Receive the size of the name encoding.

      return:   status of operation.

**********************************************************************/
AL_STATUS  AL_CERT_API
ALCertAcquireCANameByHandle
    (
        AL_HANDLE                   hCertHandle,
        PUCHAR                      pucCertEncoding,
        PVOID                       pNameEncoding,
        PULONG                      pulNameEncodingSize
    )
{
    /***********************************************************
                    DEFINITION OF LOCAL VARIABLES
    ***********************************************************/
    /*
     * pointer to the matched subject information
     */
    PCA_ENTITY                      pCAInfo      = (PCA_ENTITY)hCertHandle;
    PANSC_ASN1_CERTIFICATE          pCert;

    /*
     * debug output
     */
    CERT_TRACE("AL_CERT: ALCertAcquireCANameByHandle ...\n");

    /*
     * sanity check
     */
    if ( !hCertHandle )
    {
        return  AL_STATUS_CERT_INVALID_HANDLE;
    }

    if ( pucCertEncoding )
    {
        *pucCertEncoding = X509_SIG_ENCODING;
    }

    /* get the certificate handle */
    pCert = (PANSC_ASN1_CERTIFICATE)
        pCAInfo->GetCertHandle(pCAInfo);

    if( pCert == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS !=
          pCert->GetNameEncoding
            (
                pCert,
                pNameEncoding,
                pulNameEncodingSize
            ))
    {
        return AL_STATUS_CERT_INVALID_ENCODING_LENGTH;
    }

    return  AL_STATUS_SUCCESS;
}

/**********************************************************
 *
 *  We don't need server here.
 *
 *********************************************************/
AL_STATUS  AL_CERT_API
ALCertAddPKIServer
    (
        AL_HANDLE                   hCertContext,
        PAL_PKI_SERVER_INFO         pPKIServerInfo,
        PAL_HANDLE                  phServerHandle
    )
{
    UNREFERENCED_PARAMETER(hCertContext);
    UNREFERENCED_PARAMETER(pPKIServerInfo);
    UNREFERENCED_PARAMETER(phServerHandle);
    return AL_STATUS_CERT_NOT_SUPPORTED;
}

AL_STATUS  AL_CERT_API
ALCertImportPKIServer
    (
        AL_HANDLE                   hCertContext,
        PVOID                       pCertEncoding,
        ULONG                       ulEncodingSize,
        PVOID                       pPrivateKeyEncoding,
        ULONG                       ulKeyEncodingSize,
        PAL_HANDLE                  phServerHandle
    )
{
    UNREFERENCED_PARAMETER(hCertContext);
    UNREFERENCED_PARAMETER(pCertEncoding);
    UNREFERENCED_PARAMETER(ulEncodingSize);
    UNREFERENCED_PARAMETER(pPrivateKeyEncoding);
    UNREFERENCED_PARAMETER(ulKeyEncodingSize);
    UNREFERENCED_PARAMETER(phServerHandle);
    return AL_STATUS_CERT_NOT_SUPPORTED;
}

AL_STATUS  AL_CERT_API
ALCertRemovePKIServer
    (
        AL_HANDLE                   hServerHandle
    )
{
    UNREFERENCED_PARAMETER(hServerHandle);
    return AL_STATUS_CERT_NOT_SUPPORTED;
}

AL_STATUS  AL_CERT_API
ALCertRetrievePKIServerCert
    (
        AL_HANDLE                   hServerHandle,
        PVOID                       pCertEncoding,
        PULONG                      pulEncodingSize,
        PVOID                       pPrivateKeyEncoding,
        PULONG                      pulKeySize
    )
{
    UNREFERENCED_PARAMETER(hServerHandle);
    UNREFERENCED_PARAMETER(pCertEncoding);
    UNREFERENCED_PARAMETER(pulEncodingSize);
    UNREFERENCED_PARAMETER(pPrivateKeyEncoding);
    UNREFERENCED_PARAMETER(pulKeySize);
    return AL_STATUS_CERT_NOT_SUPPORTED;
}

AL_STATUS  AL_CERT_API
ALCertSignPKIClient
    (
        AL_HANDLE                   hServerHandle,
        PAL_PKI_CLIENT_INFO         pPKIClientInfo,
        PVOID                       pCertEncoding,
        PULONG                      pulEncodingSize,
        PVOID                       pPrivateKeyEncoding,
        PULONG                      pulKeyEncodingSize
    )
{
    UNREFERENCED_PARAMETER(hServerHandle);
    UNREFERENCED_PARAMETER(pPKIClientInfo);
    UNREFERENCED_PARAMETER(pCertEncoding);
    UNREFERENCED_PARAMETER(pulEncodingSize);
    UNREFERENCED_PARAMETER(pPrivateKeyEncoding);
    UNREFERENCED_PARAMETER(pulKeyEncodingSize);
    return AL_STATUS_CERT_NOT_SUPPORTED;
}

/********************************************************************************
    Prototype:

            AL_STATUS
            AL_CERT_API
            ALCertCreateEntity
            (
                AL_HANDLE                   hCertContext,
                PASN1_CERTIFICATE_ATTRIBUTE pAttribute,
                PAL_HANDLE                  phSubjectHandle
            )
 
    Parameter:
                AL_HANDLE                   hCertContext,
                Handle created in ALCertInitialize

                PASN1_CERTIFICATE_ATTRIBUTE         pAttribute
                The subject name attributes of Certificate request

                PAL_HANDLE                  phSubjectHandle
                The returned Subject handle if succeeded

    Comments:
                Create a subject entity with given attribute and add to the list

    Return:
                AL_STATUS_SUCCESS if succeeded

 *******************************************************************************/
AL_STATUS
AL_CERT_API
ALCertCreateEntity
(
    AL_HANDLE                   hCertContext,
    PASN1_CERTIFICATE_ATTRIBUTE pAttribute,
    PAL_HANDLE                  phSubjectHandle
)
{
    PALCERT_CONTEXT             pPKICertContext = (PALCERT_CONTEXT)hCertContext;
    PPKI_CLIENT_ENTITY          pEntity         = NULL;
    PALCERTIFICATE_ATTRIBUTE    pCertAttr;
    errno_t                     rc              = -1;

    CERT_TRACE("AL_CERT: ALCertCreateEntity() ...\n");

    if( hCertContext == NULL || pAttribute == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pCertAttr = (PALCERTIFICATE_ATTRIBUTE)
        PKICreateCertAttribute(NULL);

    pCertAttr->KeyType            = (PKI_KEY_TYPE)pAttribute->KeyType;
    pCertAttr->KeyLength          = pAttribute->KeyLength;
    pCertAttr->SignAlgor          = pAttribute->SignAlgor;

    if(pAttribute->pCountryName[0])
    {
        rc = strcpy_s(pCertAttr->pCountryName, sizeof(pCertAttr->pCountryName), pAttribute->pCountryName);
        ERR_CHK(rc);
    }

    if(pAttribute->pChallengePassword[0])
    {
        rc = strcpy_s(pCertAttr->pChallengePassword, sizeof(pCertAttr->pChallengePassword), pAttribute->pChallengePassword);
        ERR_CHK(rc);
    }

    if(pAttribute->pOrganizationName[0])
    {
        rc = strcpy_s(pCertAttr->pOrganizationName, sizeof(pCertAttr->pOrganizationName), pAttribute->pOrganizationName);
        ERR_CHK(rc);
    }

    if(pAttribute->pOrganizationUnitName[0])
    {
        rc = strcpy_s(pCertAttr->pOrganizationUnitName, sizeof(pCertAttr->pOrganizationUnitName), pAttribute->pOrganizationUnitName);
        ERR_CHK(rc);
    }

    if(pAttribute->pCommonName[0])
    {
        rc = strcpy_s(pCertAttr->pCommonName, sizeof(pCertAttr->pCommonName), pAttribute->pCommonName);
        ERR_CHK(rc);
    }

    if(pAttribute->pStateOrProvinceName[0])
    {
        rc = strcpy_s(pCertAttr->pStateOrProvinceName, sizeof(pCertAttr->pStateOrProvinceName), pAttribute->pStateOrProvinceName);
        ERR_CHK(rc);
    }

    if(pAttribute->pLocalityName[0])
    {
        rc = strcpy_s(pCertAttr->pLocalityName, sizeof(pCertAttr->pLocalityName), pAttribute->pLocalityName);
        ERR_CHK(rc);
    }

    if(pAttribute->pPKCS9Email[0])
    {
        rc = strcpy_s(pCertAttr->pPKCS9Email, sizeof(pCertAttr->pPKCS9Email), pAttribute->pPKCS9Email);
        ERR_CHK(rc);
    }

    if(pAttribute->pUnstructuredName[0])
    {
        rc = strcpy_s(pCertAttr->pUnstructedName, sizeof(pCertAttr->pUnstructedName), pAttribute->pUnstructuredName);
        ERR_CHK(rc);
    }

    if(pAttribute->pUnstructuredAddress[0])
    {
        rc = strcpy_s(pCertAttr->pUnstructedAddress, sizeof(pCertAttr->pUnstructedAddress), pAttribute->pUnstructuredAddress);
        ERR_CHK(rc);
    }

    if(pAttribute->pSubjectAltName[0])
    {
        rc = strcpy_s(pCertAttr->pSubjectAltName, sizeof(pCertAttr->pSubjectAltName), pAttribute->pSubjectAltName);
        ERR_CHK(rc);
    }

    pEntity = (PPKI_CLIENT_ENTITY)
        AnscCreatePKIEntity
            (
                pPKICertContext,
                pCertAttr,
                NULL
            );

    if( pEntity == NULL)
    {
        pCertAttr->Remove(pCertAttr);
        return AL_STATUS_FAILURE;
    }

    pCertAttr->Remove(pCertAttr);

    if(phSubjectHandle != NULL)
    {
        *phSubjectHandle = pEntity;
    }

    /* add to the list */
    pPKICertContext->AddSubjectEntity(pPKICertContext, pEntity);

    return AL_STATUS_SUCCESS;
}

/********************************************************************************
    Prototype:

            AL_STATUS
            AL_CERT_API
            ALCertCreatePKCS10CertificateRequest
            (
                AL_HANDLE                           hSubjectHandle
                PPUCHAR                             ppEncoding,
                PULONG                              pLength
            )
 
    Parameter:
                AL_HANDLE                           hSubjectHandle
                The subject handle returned from ALCertCreateEntity

                PPUCHAR                             ppEncoding
                The pointer of output buffer of Encoded PKCS10 request.

                PULONG                              pLength
                The buffer of the size of encoded PKCS10 request;

    Return:
                If the PKCS10 is generated and encoded successfully, 
                return AL_STATUS_SUCCESS;

    Comments:
                1.  If AL_STATUS_CERT_RESOURCES returned, the required memory
                    size will be set in the parameter "pLength";
                2.  The output encoding data is in binary format, if BASE64 format
                    is required, please call another API - ALCertMime64Encoding

 *******************************************************************************/
AL_STATUS
AL_CERT_API
ALCertCreatePKCS10CertificateRequest
(
    AL_HANDLE                           hSubjectHandle,
    PPUCHAR                             ppEncoding,
    PULONG                              pLength
)
{
    PPKI_CLIENT_ENTITY                  pEntity   = (PPKI_CLIENT_ENTITY)hSubjectHandle;
    PUCHAR                              pEncoding;
    ULONG                               length;
    PUCHAR                              pOutput;

    CERT_TRACE("AL_CERT: ALCertCreatePKCS10CertificateRequest() ...\n");

    if( pEntity == NULL || ppEncoding == NULL || pLength == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pEncoding = 
        pEntity->CreatePKCS10Encoding
            (
                pEntity,
                &length
            );

    if( pEncoding == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( length >= *pLength)
    {
        *pLength = length;

        AnscFreeMemory(pEncoding);

        return AL_STATUS_CERT_RESOURCES;
    }

    *pLength = length;
    pOutput = *ppEncoding;

    AnscCopyMemory
        (
            pOutput,
            pEncoding,
            length
        );

    AnscFreeMemory(pEncoding);

    return AL_STATUS_SUCCESS;
}

/********************************************************************************
    Prototype:

            BOOLEAN
            AL_CERT_API
            ALCertIsKeyMatchable
            (
                AL_HANDLE                   hCertContext,
                PVOID                       pCertEncoding,
                ULONG                       ulCertSize,
                PVOID                       pCertRequest,
                ULONG                       uRequestSize
            )
 
    Parameter:
                AL_HANDLE                   hCertContext,
                Handle created in ALCertInitialize

                PVOID                       pCertEncoding,
                ULONG                       ulCertSize,
                Certificate information

                PVOID                       pCertRequest,
                ULONG                       uRequestSize,
                PKCS10 request info which will be the output of 
                "ALCertCreatePKCS10CertificateRequest"

    Return:
                TRUE OR FALSE

 *******************************************************************************/
BOOLEAN
AL_CERT_API
ALCertIsKeyMatchable
    (
        AL_HANDLE                   hCertContext,
        PVOID                       pCertEncoding,
        ULONG                       ulCertSize,
        PVOID                       pRequestEncoding,
        ULONG                       uRequestSize
    )
{
    UNREFERENCED_PARAMETER(ulCertSize);
    UNREFERENCED_PARAMETER(uRequestSize);
    UNREFERENCED_PARAMETER(hCertContext);
    PANSC_ASN1_CERTIFICATE          pCertificate    = NULL;
    PANSC_ASN1_CERTIFICATEREQUEST   pCertRequest    = NULL;
    BOOLEAN                         bMatched        = FALSE;
    PUCHAR                          pBackBuffer     = NULL;
    PANSC_ASN1_CERTIFICATIONREQUESTINFO
                                    pInfo           = NULL;
    PANSC_ASN1_SUBJECTPUBLICKEYINFO pPublicKeyInfo1 = NULL;
    PANSC_ASN1_SUBJECTPUBLICKEYINFO pPublicKeyInfo2 = NULL;
    PUCHAR                          pPubEncode1     = NULL;
    PUCHAR                          pPubEncode2     = NULL;
    ANSC_CRYPTO_PUB_KEY_GEN_PARAMS  keyParams;
    memset(&keyParams, 0, sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS));

    if( pCertEncoding == NULL || pRequestEncoding == NULL)
    {
        goto EXIT;
    }

    /* decoding the request */
    pBackBuffer = pRequestEncoding;

    pCertRequest = (PANSC_ASN1_CERTIFICATEREQUEST)AnscAsn1CreateCertificateRequest(NULL);

    if( pCertRequest == NULL)
    {
        goto EXIT;
    }

    if( ANSC_STATUS_SUCCESS != pCertRequest->DecodingData(pCertRequest, (PVOID*)&pBackBuffer))
    {
        AnscTrace("Failed to decode PKCS10 request.\n");

        goto EXIT;
    }

    /* decoding the certificate */
    pBackBuffer = pCertEncoding;

    pCertificate = (PANSC_ASN1_CERTIFICATE)AnscAsn1CreateCertificate(NULL);

    if( pCertificate == NULL)
    {
        goto EXIT;
    }

    if( ANSC_STATUS_SUCCESS != pCertificate->DecodingData(pCertificate, (PVOID*)&pBackBuffer))
    {
        AnscTrace("Failed to decode certificate.\n");

        goto EXIT;
    }
    
    /* get the public key info for certificate */
    pPublicKeyInfo1 = (PANSC_ASN1_SUBJECTPUBLICKEYINFO)
        pCertificate->GetPublicKeyInfo(pCertificate);

    if( pPublicKeyInfo1 == NULL)
    {
        goto EXIT;
    }

    /* get the public key info for pkcs10 request */
    pInfo = (PANSC_ASN1_CERTIFICATIONREQUESTINFO)
            pCertRequest->GetCertificateRequestInfo(pCertRequest);

    if( pInfo == NULL)
    {
        goto EXIT;
    }

    pPublicKeyInfo2 = (PANSC_ASN1_SUBJECTPUBLICKEYINFO)
        pInfo->GetChildByIndex(pInfo, 2);

    if( pPublicKeyInfo2 == NULL)
    {
        goto EXIT;
    }

    /* check the 2 key info matched or not */
    pPublicKeyInfo1->ExportPublicKey(pPublicKeyInfo1, (ANSC_HANDLE)&keyParams);

    bMatched = 
        pPublicKeyInfo2->IsKeyMatching
            (
                pPublicKeyInfo2,
                pCertificate->GetKeyType(pCertificate),
                (ANSC_HANDLE)&keyParams
            );
EXIT:

    if( pCertificate != NULL)
    {
        pCertificate->AsnFree(pCertificate);
    }

    if( pCertRequest != NULL)
    {
        pCertRequest->AsnFree(pCertRequest);
    }

    if( pPubEncode1 != NULL)
    {
        AnscFreeMemory(pPubEncode1);
    }

    if( pPubEncode2 != NULL)
    {
        AnscFreeMemory(pPubEncode2);
    }

    return bMatched;
}

/**********************************************************************

    prototyp:

        AL_STATUS
        AL_CERT_API
        ALCertGetPrivateKeyInfo
            (
                AL_HANDLE                   hSubjectHandle,
                PUCHAR*                     ppKeyEncoding,
                PULONG                      pLength,
                PULONG                      pKeyType,
                PULONG                      pKeyLength
            );

    Arguments:

        AL_HANDLE                   hSubjectHandle,
        The subject handle returned from ALCertCreateEntity

        ppKeyEncoding
        Pointer to the caller allocated buffer to receive the private key

        pLength
        [IN]     specifies the maximum size the buffer can hold
        [OUT] receives the length of private key

        pKeyType
        To receive the key type: PKI_RSA_KEY or PKI_DSA_KEY

        pKeyLength
        To receive the key length in bytes

**********************************************************************/
AL_STATUS
AL_CERT_API
ALCertGetPrivateKeyInfo
    (
        AL_HANDLE                   hSubjectHandle,
        PUCHAR*                     ppKeyEncoding,
        PULONG                      pLength,
        PULONG                      pKeyType,
        PULONG                      pKeyLength
    )
{
    PPKI_CLIENT_ENTITY                  pEntity   = (PPKI_CLIENT_ENTITY)hSubjectHandle;
    PUCHAR                              pEncoding = NULL;
    ULONG                               length;
    PUCHAR                              pOutput;

    CERT_TRACE("AL_CERT: ALCertGetPrivateKeyInfo() ...\n");

    if( pEntity == NULL || ppKeyEncoding == NULL || pLength == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS !=
          pEntity->ExportInfo
            (
                pEntity,
                NULL,
                NULL,
                (PVOID*)&pEncoding,
                &length
            ))
    {
        return AL_STATUS_FAILURE;
    }

    if( length >= *pLength)
    {
        *pLength = length;

        AnscFreeMemory(pEncoding);

        return AL_STATUS_CERT_RESOURCES;
    }

    *pLength = length;
    pOutput = *ppKeyEncoding;

    AnscCopyMemory
        (
            pOutput,
            pEncoding,
            length
        );

    AnscFreeMemory(pEncoding);

    /* get the key type and length */
    if(pKeyType != NULL)
    {
        *pKeyType = (ULONG)pEntity->GetKeyType(pEntity);
    }

    if( pKeyLength != NULL)
    {
        *pKeyLength = pEntity->GetKeyLength(pEntity);
    }

    return AL_STATUS_SUCCESS;
}

/**********************************************************************

    prototyp:

        AL_STATUS
        AL_CERT_API
        ALCertSetIssuedCertificate
            (
                AL_HANDLE                   hSubjectHandle,
                PUCHAR                      pCertEncoding,
                ULONG                       length
            );

    Arguments:

        AL_HANDLE                   hSubjectHandle,
        The subject handle returned from ALCertCreateEntity

        PUCHAR                      pCertEncoding,
        The encoding of the issued certificate

        ULONG                       length
        The size of the encoding

**********************************************************************/
AL_STATUS
AL_CERT_API
ALCertSetIssuedCertificate
    (
        AL_HANDLE                   hSubjectHandle,
        PUCHAR                      pCertEncoding,
        ULONG                       length
    )
{
    PPKI_CLIENT_ENTITY              pEntity       = (PPKI_CLIENT_ENTITY)hSubjectHandle;

    CERT_TRACE("AL_CERT: ALCertSetIssuedCertificate() ...\n");

    if( hSubjectHandle == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    return
        pEntity->SetIssuedCert
            (
                pEntity,
                pCertEncoding,
                length
            );
}

/**********************************************************************

    prototyp:

        AL_STATUS
        AL_CERT_API
        ALCertSetIssuedPKCS7CertChain
            (
                AL_HANDLE                   hSubjectHandle,
                PUCHAR                      pCertEncoding,
                ULONG                       length
            );

    Arguments:

        AL_HANDLE                   hSubjectHandle,
        The subject handle returned from ALCertCreateEntity

        PUCHAR                      pCertEncoding,
        The encoding of the PKCS7 message

        ULONG                       length
        The size of the encoding

**********************************************************************/
AL_STATUS
AL_CERT_API
ALCertSetIssuedPKCS7CertChain
    (
        AL_HANDLE                   hSubjectHandle,
        PUCHAR                      pCertEncoding,
        ULONG                       length
    )
{

    PPKI_CLIENT_ENTITY              pEntity       = (PPKI_CLIENT_ENTITY)hSubjectHandle;

    CERT_TRACE("AL_CERT: ALCertSetIssuedPKCS7CertChain() ...\n");

    if( hSubjectHandle == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    return
        pEntity->SetIssuedPKCS7Certs
            (
                pEntity,
                pCertEncoding,
                length
            );

}

/********************************************************************************
    Prototype:

            AL_STATUS
            AL_CERT_API
            ALCertMime64Encoding
            (
                PVOID                               pInputData, 
                ULONG                               ulSizeOfInputData,
                PVOID                               pOutputData,
                PULONG                              pSizeOfOutputData
            )
 
    Parameter:	
                PVOID                               pInputData, 
                The input binary data;

                ULONG                               ulSizeOfInputData,
                The size of pInputData;

                PVOID                               pOutputData, 
                The output buffer;

                ULONG                               pSizeOfOutputData,
                The buffer of size of pOutputData;

    Return:
                Return AL_CERT_STATUS_SUCCESS if encode successfully;
                otherwise return the error encountered.
                Error messages include:
                AL_STATUS_CERT_RESOURCES

    Comments:
                If AL_STATUS_CERT_RESOURCES returned, the required memory
                size will be set in the parameter "pSizeOfOutputData";

 *******************************************************************************/
AL_STATUS
AL_CERT_API
ALCertMime64Encoding
(
    PVOID                               pInputData, 
    ULONG                               ulSizeOfInputData,
    PVOID                               pOutputData,
    PULONG                              pSizeOfOutputData
)
{
    PCHAR                               pOutput;
    ULONG                               length;
    errno_t                             rc = -1;

    if( pInputData == NULL || pSizeOfOutputData == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pOutput = 
        (PCHAR)AnscBase64Encode
            (
                (PUCHAR)pInputData,
                ulSizeOfInputData
            );

    if( pOutput == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    length = AnscSizeOfString(pOutput);

    if( length >= *pSizeOfOutputData)
    {
        *pSizeOfOutputData = length;
        AnscFreeMemory(pOutput);

        return AL_STATUS_CERT_RESOURCES;
    }

    *pSizeOfOutputData = length;

    rc = strcpy_s
        (
            (PCHAR)pOutputData,
            length,
            pOutput
        );
    ERR_CHK(rc);

    AnscFreeMemory(pOutput);

    return AL_STATUS_SUCCESS;
}


/********************************************************************************
    Prototype:

            AL_STATUS
            AL_CERT_API
            ALCertMime64Decoding
            (
                PVOID                               pInputData, 
                ULONG                               ulSizeOfInputData,
                PVOID                               pOutputData,
                PULONG                              pSizeOfOutputData
            )
 
    Parameter:	
                PVOID                               pInputData, 
                The input BASE64 data;

                ULONG                               ulSizeOfInputData,
                The size of pInputData;

                PVOID                               pOutputData, 
                The output buffer;

                ULONG                               pSizeOfOutputData,
                The buffer of size of pOutputData;

    Return:
                Return AL_CERT_STATUS_SUCCESS if decode successfully;
                otherwise return the error encountered.
                Error messages include:
                AL_STATUS_CERT_RESOURCES
                AL_CERT_BASE64_FAILURE

    Comments:
                If AL_STATUS_CERT_RESOURCES returned, the required memory
                size will be set in the parameter "pSizeOfOutputData";

 *******************************************************************************/
AL_STATUS
AL_CERT_API
ALCertMime64Decoding
(
    PVOID                               pInputData, 
    ULONG                               ulSizeOfInputData,
    PVOID                               pOutputData,
    PULONG                              pSizeOfOutputData
)
{
    UNREFERENCED_PARAMETER(ulSizeOfInputData);
    ULONG                               length;
    PUCHAR                              pOutput;

    if( pInputData == NULL || pOutputData == NULL || pSizeOfOutputData == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    pOutput =
        AnscBase64Decode
            (
                pInputData,
                &length
            );

    if( pOutput == NULL)
    {
        return AL_STATUS_FAILURE;
    }

    if( length >= *pSizeOfOutputData)
    {
        *pSizeOfOutputData = length;
        AnscFreeMemory(pOutput);

        return AL_STATUS_CERT_RESOURCES;
    }

    *pSizeOfOutputData = length;

    AnscCopyMemory
        (
            (PVOID)pOutputData,
            pOutput,
            length
        );

    AnscFreeMemory(pOutput);

    return AL_STATUS_SUCCESS;
}
