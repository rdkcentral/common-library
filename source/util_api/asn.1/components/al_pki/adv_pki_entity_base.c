/*
 * If not stated otherwise in this file or this component's Licenses.txt file the
 * following copyright and licenses apply:
 *
 * Copyright 2015 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**********************************************************************
   Copyright [2014] [Cisco Systems, Inc.]
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************/

/**********************************************************************

    MODULE: adv_pki_entity_base.c

        ASN.1 ANSC Code Generated by Cisco Systems, Inc.

    ---------------------------------------------------------------

    DESCRIPTION:

        This interface is for the entity of PKI implementation.

        The entity is based on basic PKI_CLIENT_ENTITY object, it has 
        further functions such as generate selfsigned certificate,
        export/import pkcs12 and etc.
    
      Internal:

        * AdvPKIEntityImportPKCS12
        * AdvPKIEntityExportPKCS12Encoding
        * AdvPKIEntityExportPKCS12Handle
        * AdvPKIEntityCreateSelfSignedCert
        * AdvPKIEntityCreateSelfSignedCertEncoding

    ---------------------------------------------------------------

    ENVIRONMENT:

        platform independent

    ---------------------------------------------------------------

    AUTHOR:

        Bin Zhu

    ---------------------------------------------------------------

    REVISION HISTORY:

        *   04/24/2003  initial revision

 **********************************************************************/

#include "ansc_pki_local.h"


/**************************************************************************************
 *
 *  static callback functions to get cert and key info from PKCS12.
 *
 **************************************************************************************/
ANSC_STATUS
initProc
    (
        ANSC_HANDLE                 hContext,
        PUCHAR                      pCertEncoding,
        ULONG                       ulCertSize,
        PUCHAR                      pKeyEncoding,
        ULONG                       ulKeyInfoSize
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hContext;
    PALCERT_CONTEXT                 pCertContext = NULL;
    PANSC_ASN1_CERTIFICATE          pNewCert = NULL;
    PUCHAR                          pEncoding = NULL;

    if( pCertEncoding == NULL || ulCertSize == 0)
    {
        return ANSC_STATUS_FAILURE;
    }

    pCertContext = (PALCERT_CONTEXT)pThisObject->hContainerContext;

    if( pKeyEncoding == NULL || ulKeyInfoSize == 0)
    {
        /* add the ca cert */
        if( pCertContext == NULL)
        {
            pNewCert = (PANSC_ASN1_CERTIFICATE)AnscAsn1CreateCertificate(NULL);

            pEncoding= pCertEncoding;
            if(pNewCert) /*RDKB-6193, CID-24363, null check before use*/
            {
                pNewCert->DecodingData(pNewCert,(PVOID*)&pEncoding);
                AnscSListPushEntryAtBack(&pThisObject->sCAList, &pNewCert->Linkage);
            }
        }
        else
        {
            pCertContext->AddTrustedCA
                (
                    pCertContext,
                    "",
                    pCertEncoding,
                    ulCertSize
                );
        }
    }
    else
    {
        pThisObject->SetIssuedCert(pThisObject, pCertEncoding, ulCertSize);
        pThisObject->SetPrivateKeyInfo(pThisObject, pKeyEncoding, ulKeyInfoSize);
    }

    if( pThisObject->pCertAttr != NULL)
    {
        pThisObject->pCertAttr->Remove(pThisObject->pCertAttr);
    }

    pThisObject->pCertAttr = GenerateAttrByCertificate(pThisObject->hUserCert);

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
AdvPKIEntityImportPKCS12
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pPKCS12Encoding,
        ULONG                       length,
        PCHAR                       pPassword
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_PFX                  pPKCS12;
    ANSC_STATUS                     status;

    if( hThisObject == NULL || pPassword == NULL || pPKCS12Encoding == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if(!AnscCheckAsn1Validity(pPKCS12Encoding, length))
    {
        AnscTrace("Invalid ASN1 encoding.\n");

        return ANSC_ASN1_INVALID_ENCODE_LENGTH;
    }

    pPKCS12 = (PANSC_ASN1_PFX)AnscAsn1CreatePFX(NULL);

    if(pPKCS12 == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* decoding the data first */
    status = pPKCS12->DecodingData(pPKCS12, (PVOID*)&pPKCS12Encoding);

    if( status != ANSC_STATUS_SUCCESS)
    {
        goto EXIT;
    }

    /* verify the HMAC signature */
    status = pPKCS12->HmacAuthenticate(pPKCS12, pThisObject->pUtilityApi, pPassword);

    if( status != ANSC_STATUS_SUCCESS)
    {
        goto EXIT;
    }

    /* decrypt it */
    status = pPKCS12->DecryptContent(pPKCS12, pThisObject->pUtilityApi, pPassword);

    if( status != ANSC_STATUS_SUCCESS)
    {
        goto EXIT;
    }

    /* get the information */
    status = 
        pPKCS12->EnumerateInfo
            (
                pPKCS12,
                initProc,
                hThisObject
            );

EXIT:

    if( pPKCS12 != NULL)
    {
        pPKCS12->AsnFree(pPKCS12);
    }

    return ANSC_STATUS_SUCCESS;
}

PUCHAR
AdvPKIEntityExportPKCS12Encoding
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pPass,
        BOOLEAN                     bExportCA,
        PULONG                      pLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_OBJECT               pPKCS12;
    PUCHAR                          pEncoding;

    if( hThisObject == NULL || pLength == NULL || pPass == NULL)
    {
        return NULL;
    }

    pPKCS12 = (PANSC_ASN1_OBJECT)pThisObject->ExportPKCS12Handle(pThisObject, pPass, bExportCA);

    if( pPKCS12 == NULL)
    {
        return NULL;
    }

    pEncoding =  pPKCS12->GetEncodedData(pPKCS12, pLength);

    pPKCS12->AsnFree(pPKCS12);

    return pEncoding;
}

ANSC_HANDLE
AdvPKIEntityExportPKCS12Handle
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pPassword,
        BOOLEAN                     bExportCA
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_PFX                  pPKCS12      = NULL;
    PANSC_ASN1_OBJECT               pCert;
    PSINGLE_LINK_ENTRY              pSListEntry;
    PUCHAR                          pEncoding,pKeyEncoding;
    ULONG                           length, keyLength;

    /* create the pkcs12 object */
    pPKCS12 = (PANSC_ASN1_PFX)AnscAsn1CreatePFX(NULL);

    if( pPKCS12 == NULL)
    {
        return NULL;
    }

    if( bExportCA)
    {
        /* export the CA one by one */
        pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sCAList);

        while( pSListEntry != NULL)
        {
            pCert      = ACCESS_ANSC_ASN1_OBJECT(pSListEntry);
            pSListEntry = AnscSListGetNextEntry(pSListEntry);

            if( pCert != NULL)
            {
                pEncoding = pCert->GetEncodedData(pCert, &length);

                if( pEncoding != NULL)
                {
                    pPKCS12->AddCertificate
                        (
                            pPKCS12,
                            pEncoding,
                            length
                        );
#if 0                     /*RDKB-6193, CID-33132; Do not free the pPKCS12; leads to memory violation*/
                    AnscFreeMemory(pPKCS12);
#endif
                }
            }              
        }
    }

    /* export the user's certificate */
    if( pThisObject->ExportInfo
            (
                pThisObject,
                (PVOID*)&pEncoding,
                &length,
                (PVOID*)&pKeyEncoding,
                &keyLength
            ) == ANSC_STATUS_SUCCESS
       )
    {
        pPKCS12->AddCertAndKeyInfo(pPKCS12, pEncoding, length, pKeyEncoding, keyLength);

        if( pEncoding != NULL)
        {
            AnscFreeMemory(pEncoding);
        }

        if( pKeyEncoding != NULL)
        {
            AnscFreeMemory(pKeyEncoding);
        }
    }

    /* encrypt it */
    pPKCS12->EncryptAndSign
         (
            pPKCS12,
            pThisObject->pUtilityApi,
            pPassword
         );

    return pPKCS12;
}


ANSC_HANDLE
AdvPKIEntityCreateSelfSignedCert
    (
        ANSC_HANDLE                 hThisObject,
        BOOLEAN                     bHasKeyIdentifier
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;

    if( pThisObject == NULL || pThisObject->pCertAttr == NULL)
    {
        return NULL;
    }

    if( pThisObject->hCryptAPI == NULL)
    {
        return
            AnscAsn1GenerateSelfSignedCertificate
                (   
                    NULL,
                    pThisObject->pCertAttr,
                    pThisObject->hKeyParam,
                    bHasKeyIdentifier
                );
    }
    else
    {
        return
            AnscAsn1GenSelfSignedCertificateWithCryptoAPI
                (   
                    NULL,
                    pThisObject->pCertAttr,
                    pThisObject->hCryptAPI,
                    bHasKeyIdentifier
                );
    }

    return NULL;

}

PUCHAR
AdvPKIEntityCreateSelfSignedCertEncoding
    (
        ANSC_HANDLE                 hThisObject,
        BOOLEAN                     bHasKeyIdentifier,
        PULONG                      pLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_OBJECT               pCert;
    PUCHAR                          pEncoding;

    if( hThisObject == NULL || pLength == NULL)
    {
        return NULL;
    }

    pCert = (PANSC_ASN1_OBJECT)pThisObject->CreateSelfSignedCert(pThisObject,bHasKeyIdentifier);

    if( pCert == NULL)
    {
        return NULL;
    }

    pEncoding =  pCert->GetEncodedData(pCert, pLength);

    pCert->AsnFree(pCert);

    return pEncoding;

}

ANSC_STATUS
AdvPKIEntitySetIssuedPKCS7Certs
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{

    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PUCHAR                          pBack        = pEncoding;
    PANSC_ASN1_CONTENTINFO          pInfo        = NULL;
    PANSC_ASN1_SIGNEDDATA           pSignedData;
    PANSC_ASN1_CERTIFICATE          pCert, pCloned;
    ANSC_STATUS                     retStatus    = ANSC_STATUS_SUCCESS;
    ULONG                           count,i;
    BOOL                            bFound       = FALSE;
    ANSC_CRYPTO_PUB_KEY_GEN_PARAMS  genParams;
    PKI_KEY_TYPE                    keyType;
    PALCERT_CONTEXT                 pCertContext = NULL;
    PUCHAR                          pCertEncoding;
    ULONG                           certLength;

    if( hThisObject == NULL || pEncoding == NULL || length <= 8)
    {
        return ANSC_STATUS_FAILURE;
    }

    if(!AnscCheckAsn1Validity(pEncoding, length))
    {
        AnscTrace("Invalid ASN1 encoding.\n");

        return ANSC_ASN1_INVALID_ENCODE_LENGTH;
    }

    /* create the content info and decode from the encoding */
    pInfo = (PANSC_ASN1_CONTENTINFO)AnscAsn1CreateContentInfo(NULL);

    if( pInfo == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    retStatus = 
        pInfo->DecodingData(pInfo, (PVOID*)&pBack);

    if( retStatus != ANSC_STATUS_SUCCESS)
    {
        goto EXIT;
    }

    /* get the signed data */
    pSignedData = (PANSC_ASN1_SIGNEDDATA)
        pInfo->GetSignedData(pInfo);

    if( pSignedData == NULL)
    {
        retStatus = ANSC_STATUS_FAILURE;

        goto EXIT;
    }

    /* get the certificate */
    count = pSignedData->GetTotalCerts(pSignedData);

    if( count == 0)
    {
        retStatus = ANSC_STATUS_FAILURE;

        goto EXIT;
    }

    /* add the certificate one by one */
    pThisObject->GetPublicKeyInfo
        (
            pThisObject,
            &keyType,
            &genParams
        );

    pCertContext = (PALCERT_CONTEXT)pThisObject->hContainerContext;

    for( i = 0; i < count; i ++)
    {
        pCert = (PANSC_ASN1_CERTIFICATE)
            pSignedData->GetCertificateByIndex(pSignedData, i);

        if( pCert != NULL)
        {
            pCloned = (PANSC_ASN1_CERTIFICATE)pCert->Clone(pCert);

            if( pCloned == NULL)
            {   
                retStatus = ANSC_STATUS_RESOURCES;

                goto EXIT;
            }

            if( bFound == FALSE &&
                pCert->IsKeyMatching
                    (
                        pCert,
                        keyType,
                        &genParams
                    )
              )
            {
                /* remove the old one */
                if( pThisObject->hUserCert != NULL)
                {
                    ((PANSC_ASN1_OBJECT)pThisObject->hUserCert)->AsnFree(pThisObject->hUserCert);
                }
                
                if( pThisObject->pCertEncoding != NULL)
                {
                    AnscFreeMemory(pThisObject->pCertEncoding);
                }

                /* set the new one and copy the encoding */
                pThisObject->hUserCert      = pCloned;
                pThisObject->pCertEncoding  =
                    pCloned->GetEncodedData
                        (
                            pCloned,
                            &pThisObject->uLength
                        );

                bFound = TRUE;
            }
            else
            {
                if( pCertContext == NULL)
                {
                    AnscSListPushEntryAtBack(&pThisObject->sCAList, &pCloned->Linkage);
                }
                else
                {
                    pCertEncoding = pCloned->GetEncodedData(pCloned, &certLength);

                    pCloned->AsnFree(pCloned);

                    pCertContext->AddTrustedCA
                        (
                            pCertContext,
                            "",
                            pCertEncoding,
                            certLength
                        );

                    AnscFreeMemory(pCertEncoding);
                }
            }
        }
    }    

EXIT:

    if( pInfo != NULL)
    {
        pInfo->AsnFree(pInfo);
    }

    return retStatus;
}

