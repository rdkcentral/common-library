/*
 * If not stated otherwise in this file or this component's Licenses.txt file the
 * following copyright and licenses apply:
 *
 * Copyright 2015 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**********************************************************************
   Copyright [2014] [Cisco Systems, Inc.]
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************/

/**********************************************************************

    MODULE: pki_entity_base.c

        ASN.1 ANSC Code Generated by Cisco Systems, Inc.

    ---------------------------------------------------------------

    DESCRIPTION:

        This interface is for the entity of PKI implementation.

        The entity is responsible for generating key pair, pkcs10
        certificate request, self-signed certificate.

        *   AnscCreatePKIEntity
        *   AnscCreatePKIEntityWithCryptoAPI
        *   AnscCreatePKIEntityWithCert
        *   AnscCreatePKIEntityWithKeyPair

        *   PKIEntityRemove
        *   PKIEntityRemoveEntityCert
        *   PKIEntityGetKeyType
        *   PKIEntityGetKeyLength
        *   PKIEntityGetPublicKey
        *   PKIEntitySignData
        *   PKIEntityVerify
        *   PKIEntityDecryptData
        *   PKIEntityEncryptData
        *   PKIEntityGetCACount
        *   PKIEntityGetCAByIndex
        *   PKIEntityCreatePKCS10
        *   PKIEntityCreatePKCS10Encoding
        *   PKIEntityGetEntityCert
        *   PKIEntitySetCertHandle
        *   PKIEntitySetIssuedCert
        *   PKIEntitySetPrivateKeyInfo
        *   PKIEntityIssueCert
        *   PKIEntityExportInfo
        *   PKIEntityExportToFile
        *   PKIEntityGetName
        *   PKIEntitySetName

    ---------------------------------------------------------------

    ENVIRONMENT:

        platform independent

    ---------------------------------------------------------------

    AUTHOR:

        Bin Zhu

    ---------------------------------------------------------------

    REVISION HISTORY:

        *   08/13/2002  initial revision
        *   12/01/2003  add name field support

 **********************************************************************/

#include "ansc_pki_local.h"
#include "safec_lib_common.h"

void 
InitPKIEntityAPIs
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;

    /*
     *  init all the functions here 
     */
    pThisObject->Remove                         = PKIEntityRemove;
    pThisObject->RemoveEntityCert               = PKIEntityRemoveEntityCert;
    pThisObject->GetKeyType                     = PKIEntityGetKeyType;
    pThisObject->GetKeyLength                   = PKIEntityGetKeyLength;
    pThisObject->GetPublicKeyInfo               = PKIEntityGetPublicKey;
    pThisObject->SignData                       = PKIEntitySignData;
    pThisObject->Verify                         = PKIEntityVerify;
    pThisObject->DecryptData                    = PKIEntityDecryptData;
    pThisObject->EncryptData                    = PKIEntityEncryptData;
    pThisObject->GetCACount                     = PKIEntityGetCACount;
    pThisObject->GetCAByIndex                   = PKIEntityGetCAByIndex;
    pThisObject->CreatePKCS10                   = PKIEntityCreatePKCS10;
    pThisObject->CreatePKCS10Encoding           = PKIEntityCreatePKCS10Encoding;
    pThisObject->GetEntityCert                  = PKIEntityGetEntityCert;
    pThisObject->SetCertHandle                  = PKIEntitySetCertHandle;
    pThisObject->SetIssuedCert                  = PKIEntitySetIssuedCert;
    pThisObject->SetPrivateKeyInfo              = PKIEntitySetPrivateKeyInfo;
    pThisObject->IssueCertificate               = PKIEntityIssueCert;
    pThisObject->ExportInfo                     = PKIEntityExportInfo;
    pThisObject->ExportToFile                   = PKIEntityExportToFile;
    pThisObject->GetName                        = PKIEntityGetName;
    pThisObject->SetName                        = PKIEntitySetName;

    AnscZeroMemory(pThisObject->pName, MAXI_ENTITY_NAME_BUFFER);

    /* init the CA cert list */
    AnscSListInitializeHeader(&pThisObject->sCAList);

    pThisObject->ImportPKCS12                  = AdvPKIEntityImportPKCS12; 
    pThisObject->ExportPKCS12Encoding          = AdvPKIEntityExportPKCS12Encoding;
    pThisObject->ExportPKCS12Handle            = AdvPKIEntityExportPKCS12Handle;
    pThisObject->CreateSelfSignedCert          = AdvPKIEntityCreateSelfSignedCert;
    pThisObject->CreateSelfSignedCertEncoding  = AdvPKIEntityCreateSelfSignedCertEncoding;
    pThisObject->SetIssuedPKCS7Certs           = AdvPKIEntitySetIssuedPKCS7Certs;

    pThisObject->pUtilityApi = 
        (PPKCS12_UTILITY_INTERFACE)AnscCreatePKCS12Utility(pThisObject, NULL);
}

/*************************************************************************
 *
 * This is the basic api to generate a PKI_ENTITY which is responsible to 
 * generate the key pair, PKCS10 request and selfsigned certificate.
 *
 * The handle "hCertAttr" could not be NULL here.
 *
 *************************************************************************/
ANSC_HANDLE 
AnscCreatePKIEntity
    (
        ANSC_HANDLE                 hContext,
        ANSC_HANDLE                 hCertAttr,
        ANSC_HANDLE                 hReserved
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = NULL;
    PALCERTIFICATE_ATTRIBUTE        pCertAttr    = (PALCERTIFICATE_ATTRIBUTE)hCertAttr;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    ANSC_CRYPTO_PUB_ALGORITHM       Alg;
    ANSC_CRYPTO_PUB_OPERATION       Op;
    PANSC_CRYPTO_PUB_KEY_GEN_PARAMS pGenParams;

    if( hCertAttr == NULL)
    {
        return pThisObject;
    }

    if( pCertAttr->KeyType != PKI_RSA_KEY && pCertAttr->KeyType != PKI_DSA_KEY)
    {
        AnscTrace("Only RSA and DSA are supported at this version.\n");

        return pThisObject;
    }

    /* get the right length */
    if( pCertAttr->KeyLength < 64 || pCertAttr->KeyLength % 8 != 0)
    {
        pCertAttr->KeyLength = 128; /* default key length */
    }

    if( pCertAttr->KeyType == PKI_DSA_KEY)
    {
        pCertAttr->SignAlgor      = DSA_SHA1_SIGNATURE;
    }

    /* create the entity */
    if( hReserved != NULL)
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    (ULONG)hReserved
                );
    }
    else
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    sizeof(PKI_CLIENT_ENTITY)
                );
    }

    if( pThisObject == NULL)
    {
        return (ANSC_HANDLE)NULL;
    }

    /* init the parameter */
    if( pCertAttr->Clone != NULL)
    {
        pThisObject->pCertAttr = (PALCERTIFICATE_ATTRIBUTE)
            pCertAttr->Clone(pCertAttr);
    }

    if( pThisObject->pCertAttr == NULL)
    {
        pThisObject->Remove(pThisObject);

        AnscTrace("Failed to create the CertAttribute.\n");

        return NULL;
    }

    pThisObject->hContainerContext              = hContext;
    pThisObject->hCryptAPI                      = NULL;
    pThisObject->hUserCert                      = NULL;
    pThisObject->pCertEncoding                  = NULL;
    pThisObject->uLength                        = 0;

    /*
     *  init all the functions here 
     */
    InitPKIEntityAPIs(pThisObject);
   
    /*
     *  Create the CryptoSSL
     */   
    pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)AnscCreateCryptoPubSSLeay(NULL);
    pThisObject->hCryptoSSL = pSSLCrypto;

    if( pThisObject->hCryptoSSL == NULL)
    {
        pThisObject->Remove(pThisObject);

        return NULL;
    }

    /*
     *  Generate the key pair 
     */
    pThisObject->hKeyParam  = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
        AnscAllocateMemory(sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS));

    if( pThisObject->hKeyParam == NULL)
    {
        pThisObject->Remove(pThisObject);

        AnscTrace("Failed to generate the key pair.\n");

        return NULL;
    }

    pGenParams = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)pThisObject->hKeyParam;

    if( pCertAttr->KeyType == PKI_RSA_KEY)
    {
        Alg     = ANSC_CRYPTO_PUB_ALGORITHM_RSA_SIGNATURE;
        pGenParams->PublicKey.RSA.Modulus.Length  = pCertAttr->KeyLength;
    }
    else
    {
        Alg     = ANSC_CRYPTO_PUB_ALGORITHM_DSA;
        pGenParams->PublicKey.DSA.ParamQ.Length   = pCertAttr->KeyLength;
        pGenParams->PublicKey.DSA.ParamP.Length   = pCertAttr->KeyLength;
    }

    Op      = ANSC_CRYPTO_PUB_OPERATION_GENERATE;

    pSSLCrypto->Request(Alg, Op, pGenParams, NULL, NULL);

    return pThisObject;
}

/**************************************************************************
 *  For smartcard support
 *
 *  If the private key is not accessible, the cryptoAPI is
 *  required to sign and decrypt data.
 *
 *  The CryptoAPI was defined in "crypt_proc.h"
 *
 *  typedef  struct
 *  _CRYPT_API_STRUCT
 *  {
 *          CRYPT_GETKEYTYPE_PROC       pGetKeyType;
 *          CRYPT_GETKEYLENGTH_PROC     pGetKeyLength;
 *          CRYPT_GETPUBLICKEYINFO_PROC pGetPublicKeyInfo;
 *          CRYPT_SIGNDATA_PROC         pSignData;
 *          CRYPT_ENCRYPTDATA_PROC      pEncryptData;
 *          CRYPT_DECRYPTDATA_PROC      pDecryptData;
 *  }
 *  CRYPT_API_STRUCT, *PCRYPT_API_STRUCT;
 *
 * NOTE:  
 *  A. The "hCertAttr" here could be NULL if subject cert is already
 *     available.
 *  B. The entity will make a copy of the CryptoAPI handle.
 *
 **************************************************************************/
ANSC_HANDLE 
AnscCreatePKIEntityWithCryptoAPI
    (
        ANSC_HANDLE                 hContext,
        ANSC_HANDLE                 hCertAttr,
        ANSC_HANDLE                 hCryptoAPI,
        ANSC_HANDLE                 hReserved
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = NULL;

    PALCERTIFICATE_ATTRIBUTE        pCertAttr    = (PALCERTIFICATE_ATTRIBUTE)hCertAttr;
    PCRYPT_API_STRUCT               pCryptoAPI   = (PCRYPT_API_STRUCT)hCryptoAPI;

    if( hCryptoAPI == NULL)
    {
        return pThisObject;
    }

    /* make sure it's a valid cryptoAPI */
    if( pCryptoAPI->pGetPublicKey == NULL || pCryptoAPI->pGetKeyLength == NULL ||
        pCryptoAPI->pGetKeyType   == NULL || pCryptoAPI->pSignData     == NULL)
    {
        AnscTrace("This is not a valid smartcard CryptoAPI.\n");

        return pThisObject;
    }

    if( pCertAttr != NULL)
    {
        if( pCertAttr->KeyType == PKI_DSA_KEY)
        {
            pCertAttr->SignAlgor      = DSA_SHA1_SIGNATURE;
        }

        if( pCertAttr->KeyType != PKI_RSA_KEY && pCertAttr->KeyType != PKI_DSA_KEY)
        {
            AnscTrace("Only RSA and DSA are supported at this version.\n");

            return pThisObject;
        }

        /* get the right length */
        if( pCertAttr->KeyLength < 64 || pCertAttr->KeyLength % 8 != 0)
        {
            pCertAttr->KeyLength = 128; /* default key length */
        }
    }

    /* create the entity */
    if( hReserved != NULL)
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    (ULONG)hReserved
                );
    }
    else
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    sizeof(PKI_CLIENT_ENTITY)
                );
    }

    if( pThisObject == NULL)
    {
        return (ANSC_HANDLE)NULL;
    }

    /*
     *  Create the CryptoSSL
     */
    pThisObject->hCryptoSSL = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)AnscCreateCryptoPubSSLeay(NULL);

    if( pThisObject->hCryptoSSL == NULL)
    {
        pThisObject->Remove(pThisObject);

        return NULL;
    }

    /* init the parameter */
    if( pCertAttr != NULL)
    {
        pThisObject->pCertAttr = (PALCERTIFICATE_ATTRIBUTE)
            pCertAttr->Clone(pCertAttr);

        if( pThisObject->pCertAttr == NULL)
        {
            pThisObject->Remove(pThisObject);

            AnscTrace("Failed to create the CertAttribute.\n");

            return NULL;
        }
    }

    pThisObject->hContainerContext              = hContext;
    pThisObject->hUserCert                      = NULL;
    pThisObject->pCertEncoding                  = NULL;
    pThisObject->uLength                        = 0;

    /*
     *  init all the functions here 
     */
    InitPKIEntityAPIs(pThisObject);
   
    /* save the cryptoAPI */
    pThisObject->hCryptAPI = hCryptoAPI;

    return pThisObject;
}

/*************************************************************************
 *
 * This api is for the old AL_CERT implementation which have certificate
 * and private key encoding ready and don't need generating PKCS10 request
 * or selfsigned-certificate.
 *
 *************************************************************************/
PALCERTIFICATE_ATTRIBUTE
GenerateAttrByCertificate
    (
        PANSC_ASN1_CERTIFICATE      pCert
    )
{
    PALCERTIFICATE_ATTRIBUTE        pAttr;
    CHAR                            pBuffer[512] = { 0 };
    ULONG                           length       = 512;
    PANSC_ASN1_NAME                 pNameObj;

    if( pCert == NULL)
    {
        return NULL;
    }

    /* get the name */
    pNameObj = (PANSC_ASN1_NAME)pCert->GetSubjectHandle(pCert);

    pNameObj->ExportToString(pNameObj, pBuffer, &length);

    /* create the new attr and init */
    pAttr = (PALCERTIFICATE_ATTRIBUTE)
        PKICreateCertAttribute(NULL);

    if( pAttr == NULL)
    {
        return pAttr;
    }

    pAttr->InitRFC2253Encode(pAttr, pBuffer);

    pAttr->KeyType   = pCert->GetKeyType(pCert);
    pAttr->KeyLength = pCert->GetKeyBits(pCert) / 8;

    /* get the signature type */
    pAttr->SignAlgor = pCert->GetSignatureType(pCert);

    return pAttr;
}

/*************************************************************************
 *
 * This api is for the old AL_CERT implementation which have certificate
 * and private key encoding ready and don't need generating PKCS10 request
 * or selfsigned-certificate.
 *
 *************************************************************************/
ANSC_HANDLE 
AnscCreatePKIEntityWithCert
    (
        ANSC_HANDLE                 hContext,
        ANSC_HANDLE                 hReserved,
        ANSC_HANDLE                 hCertAttr,
        PUCHAR                      pEncodingCert,
        ULONG                       lenOfCert,
        PUCHAR                      pPriKeyInfoEncode,
        ULONG                       lenOfKey
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = NULL;
    PANSC_ASN1_CERTIFICATE          pCert        = NULL;
    PUCHAR                          pBack;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    PALCERTIFICATE_ATTRIBUTE        pCertAttr    = (PALCERTIFICATE_ATTRIBUTE)hCertAttr;

    if( pEncodingCert == NULL || lenOfCert == 0 || pPriKeyInfoEncode == NULL || lenOfKey == 0)
    {
        return NULL;
    }

    if(!AnscCheckAsn1Validity(pEncodingCert, lenOfCert))
    {
        AnscTrace("Invalid Certificate encoding.\n");

        return NULL;
    }

    if(!AnscCheckAsn1Validity(pPriKeyInfoEncode, lenOfKey))
    {
        AnscTrace("Invalid PrivateKeyInfo encoding.\n");

        return NULL;
    }

    /* decode the cert */
    pBack = pEncodingCert;

    pCert = (PANSC_ASN1_CERTIFICATE)AnscAsn1CreateCertificate(NULL);

    if( pCert == NULL)
    {
        goto EXIT;
    }

    if( ANSC_STATUS_SUCCESS != pCert->DecodingData(pCert, (PVOID*)&pBack))
    {
        goto EXIT;
    }

    /* Create the entity */
    if( hReserved != NULL)
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    (ULONG)hReserved
                );
    }
    else
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    sizeof(PKI_CLIENT_ENTITY)
                );
    }

    if( pThisObject == NULL)
    {
        goto EXIT;
    }

    pThisObject->hContainerContext              = hContext;
    pThisObject->hCryptAPI                      = NULL;
    pThisObject->hUserCert                      = NULL;
    pThisObject->pCertEncoding                  = NULL;
    pThisObject->uLength                        = 0;

    /*
     *  init all the functions here 
     */
    InitPKIEntityAPIs(pThisObject);
   
    /*
     *  Create the CryptoSSL
     */   
    pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)AnscCreateCryptoPubSSLeay(NULL);
    pThisObject->hCryptoSSL = pSSLCrypto;

    if( pThisObject->hCryptoSSL == NULL)
    {
        goto EXIT;
    }

    /* Init the keyGenParam object */
    pThisObject->hKeyParam = (PUCHAR)AnscAllocateMemory(sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS));

    if( pThisObject->hKeyParam == NULL)
    {
        goto EXIT;
    }

    /* chcek the cert attribute */
    if( hCertAttr != NULL)
    {   
        pCertAttr->KeyType     = pCert->GetKeyType(pCert);
        pThisObject->pCertAttr = (PALCERTIFICATE_ATTRIBUTE)
            pCertAttr->Clone(pCertAttr);

        if( pThisObject->pCertAttr == NULL)
        {   
            AnscTrace("Failed to create cert attribute.\n");
        }

    }
    else
    {
        pThisObject->pCertAttr = 
            GenerateAttrByCertificate
                (
                    pCert 
                );

        if( pThisObject->pCertAttr == NULL)
        {   
            AnscTrace("Failed to create cert attribute.\n");
        }
    }

    /* make a copy of the cert encoding */
    pThisObject->pCertEncoding = (PUCHAR)
        AnscAllocateMemory(lenOfCert + 4);

    if( pThisObject->pCertEncoding != NULL)
    {
        pThisObject->uLength = lenOfCert;
        
        AnscCopyMemory
            (
                pThisObject->pCertEncoding,
                pEncodingCert,
                lenOfCert
            );
    }

    /* set the user handle */
    pThisObject->hUserCert = (ANSC_HANDLE)pCert;
    pCert                  = NULL;

    if( ANSC_STATUS_SUCCESS !=
        pThisObject->SetPrivateKeyInfo
        (
            pThisObject, 
            pPriKeyInfoEncode,
            lenOfKey
        ))
    {
        AnscTrace("Failed to load the cert and keyinfo.\n");

        goto EXIT;
    }

    return pThisObject;

EXIT:

    if( pCert != NULL)
    {
        pCert->AsnFree(pCert);
    }

    if( pThisObject != NULL)
    {
        pThisObject->Remove(pThisObject);
    }

    return NULL;
}

/*************************************************************************
 *
 * This api is for the user entity already has key pair but no certificate
 * yet.
 *
 *************************************************************************/
ANSC_HANDLE 
AnscCreatePKIEntityWithKeyPair
    (
        ANSC_HANDLE                 hContext,
        ANSC_HANDLE                 hReserved,
        PCHAR                       pDNName,
        ULONG                       keyType,
        ANSC_HANDLE                 hKeyPair
    )
{
    PANSC_CRYPTO_PUB_KEY_GEN_PARAMS pGenParams   = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)hKeyPair;
    PPKI_CLIENT_ENTITY              pThisObject  = NULL;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    PALCERTIFICATE_ATTRIBUTE        pCertAttr    = NULL;
    BOOL                            bKeyPairMatch= FALSE;

    /* Create the entity */
    if( hReserved != NULL)
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    (ULONG)hReserved
                );
    }
    else
    {
        pThisObject = (PPKI_CLIENT_ENTITY)
            AnscAllocateMemory
                (
                    sizeof(PKI_CLIENT_ENTITY)
                );
    }

    if( pThisObject == NULL)
    {
        goto EXIT;
    }

    pThisObject->hContainerContext              = hContext;
    pThisObject->hCryptAPI                      = NULL;
    pThisObject->hUserCert                      = NULL;
    pThisObject->pCertEncoding                  = NULL;
    pThisObject->uLength                        = 0;

    /*
     *  init all the functions here 
     */
    InitPKIEntityAPIs(pThisObject);
   
    pCertAttr = (PALCERTIFICATE_ATTRIBUTE)
        PKICreateCertAttributeWithName
            (
                NULL,
                pDNName
            );

    if( pCertAttr == NULL)
    {
        goto EXIT;
    }

    pCertAttr->KeyType = keyType;

    if( keyType == PKI_RSA_KEY)
    {
        pCertAttr->SignAlgor            = RSA_MD5_SIGNATURE;
        pCertAttr->KeyLength            = pGenParams->PublicKey.RSA.Modulus.Length / 8 * 8;
    }
    else
    {
        pCertAttr->SignAlgor            = DSA_SHA1_SIGNATURE;
        pCertAttr->KeyLength            = pGenParams->PublicKey.DSA.ParamP.Length / 8 * 8;
    }

    pThisObject->pCertAttr = pCertAttr; 

    /*
     *  Create the CryptoSSL
     */   
    pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)AnscCreateCryptoPubSSLeay(NULL);
    pThisObject->hCryptoSSL = pSSLCrypto;

    if( pThisObject->hCryptoSSL == NULL)
    {
        goto EXIT;
    }

    /* Init the keyGenParam object */
    pThisObject->hKeyParam = (PUCHAR)AnscAllocateMemory(sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS));

    if( pThisObject->hKeyParam == NULL)
    {
        goto EXIT;
    }

    AnscCopyMemory
        (
            pThisObject->hKeyParam,
            hKeyPair,
            sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
        );

    /* check the key pair */
    if( keyType == PKI_RSA_KEY)
    {
        bKeyPairMatch = 
            pSSLCrypto->KeyPairMatch
                (
                    pSSLCrypto,
                    ANSC_CRYPTO_PUB_KEY_RSA,
                    &pGenParams->PublicKey.RSA,
                    &pGenParams->PrivateKey.RSA
                );
    }
    else
    {
        bKeyPairMatch = 
            pSSLCrypto->KeyPairMatch
                (
                    pSSLCrypto,
                    ANSC_CRYPTO_PUB_KEY_DSA,
                    &pGenParams->PublicKey.DSA,
                    &pGenParams->PrivateKey.DSA
                );
    }

    if( !bKeyPairMatch)
    {
        AnscTrace("The entity has an invalid key pair.\n");

        goto EXIT;
    }

    return pThisObject;

EXIT:

    if( pThisObject != NULL)
    {
        pThisObject->Remove(pThisObject);
    }

    return NULL;
}

/*
 *  Free the entity;
 */
ANSC_STATUS
removeAllCAs
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_OBJECT               pCert;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_SUCCESS;
    }

    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sCAList);

    while( pSListEntry != NULL)
    {
        pCert      = ACCESS_ANSC_ASN1_OBJECT(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pCert != NULL)
        {
            pCert->AsnFree(pCert);
        }              
    }

    /*
     *  reset the SList;
     */
    AnscSListInitializeHeader(&pThisObject->sCAList);

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
PKIEntityRemove
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    PANSC_ASN1_CERTIFICATE          pCert;
    PPKCS12_UTILITY_INTERFACE       pUtility;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_SUCCESS;
    }

    pUtility = (PPKCS12_UTILITY_INTERFACE)pThisObject->pUtilityApi;

    if( pUtility != NULL)
    {
        pUtility->Remove(pUtility);
    }

    /* check the sslcrypto */
    pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)pThisObject->hCryptoSSL;

    if( pSSLCrypto != NULL)
    {
        pSSLCrypto->Remove(pSSLCrypto);
    }

    /* free the attribute */
    if( pThisObject->pCertAttr != NULL)
    {
        pThisObject->pCertAttr->Remove
            (
                pThisObject->pCertAttr
            );
    }

    if( pThisObject->hKeyParam != NULL)
    {
        AnscFreeMemory(pThisObject->hKeyParam);
    }

    /* free the user cert */
    if( pThisObject->hUserCert != NULL)
    {
        pCert = (PANSC_ASN1_CERTIFICATE)
            pThisObject->hUserCert;

        pCert->AsnFree(pCert);
    }

    /* free the cert encoding */
    if( pThisObject->pCertEncoding != NULL)
    {
        AnscFreeMemory(pThisObject->pCertEncoding);
    }

    /* free all the CAs */
    removeAllCAs(hThisObject);

    /* free the object */
    AnscFreeMemory(hThisObject);

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
PKIEntityRemoveEntityCert
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCert;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_SUCCESS;
    }

    /* free the user cert */
    if( pThisObject->hUserCert != NULL)
    {
        pCert = (PANSC_ASN1_CERTIFICATE)
            pThisObject->hUserCert;

        pCert->AsnFree(pCert);

        pThisObject->hUserCert = NULL;
    }

    /* free the cert encoding */
    if( pThisObject->pCertEncoding != NULL)
    {
        AnscFreeMemory(pThisObject->pCertEncoding);

        pThisObject->pCertEncoding = NULL;
        pThisObject->uLength       = 0;
    }

    return ANSC_STATUS_SUCCESS;
}

/**************************************************************
 *  Get the total count of the CA chain
 ***************************************************************/
ULONG
PKIEntityGetCACount
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;

    if( pThisObject == NULL)
    {
        return 0;
    }

    return AnscSListQueryDepth(&pThisObject->sCAList);
}

/**************************************************************
 *  Get the CA cert with given index;
 **************************************************************/
ANSC_HANDLE
PKIEntityGetCAByIndex
    (
        ANSC_HANDLE                 hThisObject,
        ULONG                       ulIndex
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PSINGLE_LINK_ENTRY              pSListEntry;

    pSListEntry = 
        AnscSListGetEntryByIndex
            (
                &pThisObject->sCAList,
                ulIndex
            );

    if( pSListEntry == NULL)
    {
        return NULL;
    }

    return ACCESS_ANSC_ASN1_OBJECT(pSListEntry);

}

/**************************************************************
 * Generate handle procs, such as PKCS10, Selfsigned Cert Handles
 *
 * NOTE: The caller is responsible to free it
 *
 * pHandle->AsnFree(pHandle);
 **************************************************************/
ANSC_HANDLE
PKIEntityCreatePKCS10
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;

    if( pThisObject == NULL || pThisObject->pCertAttr == NULL)
    {
        return NULL;
    }

    if( pThisObject->hCryptAPI == NULL)
    {
        return
            AnscAsn1GeneratePKCS10Request
                (   
                    NULL,
                    pThisObject->pCertAttr,
                    pThisObject->hKeyParam
                );
    }
    else
    {
        return
            AnscAsn1GenPKCS10RequestWithCryptoAPI
                (   
                    NULL,
                    pThisObject->pCertAttr,
                    pThisObject->hCryptAPI
                );
    }

    return NULL;
}

/**************************************************************
 * Generate Encoding, such as PKCS10, Selfsigned Cert encodings
 *
 * NOTE: The caller is responsible to free the buffer
 *
 * AnscFreeMemory(...)
 **************************************************************/
PUCHAR
PKIEntityCreatePKCS10Encoding
    (
        ANSC_HANDLE                 hThisObject,
        PULONG                      pLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_OBJECT               pPKCS10;
    PUCHAR                          pEncoding;

    if( hThisObject == NULL || pLength == NULL)
    {
        return NULL;
    }

    pPKCS10 = (PANSC_ASN1_OBJECT)pThisObject->CreatePKCS10(pThisObject);

    if( pPKCS10 == NULL)
    {
        return NULL;
    }

    pEncoding = pPKCS10->GetEncodedData(pPKCS10, pLength);

    pPKCS10->AsnFree(pPKCS10);

    return pEncoding;
}


/**************************************************************
 * Get certain handle
 **************************************************************/
ANSC_HANDLE
PKIEntityGetEntityCert
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;

    if( hThisObject != NULL)
    {
        return pThisObject->hUserCert;
    }

    return NULL;
}

/**************************************************************
 * Set certain handle
 **************************************************************/
ANSC_STATUS
PKIEntitySetCertHandle
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCert
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCertificate = (PANSC_ASN1_CERTIFICATE)hCert;

    if( hThisObject == NULL || hCert == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if( pThisObject->hUserCert != NULL)
    {
        ((PANSC_ASN1_OBJECT)pThisObject->hUserCert)->AsnFree(pThisObject->hUserCert);
    }

    pThisObject->hUserCert = hCert;

    /* get the encoding */
    if( pThisObject->pCertEncoding != NULL)
    {
        AnscFreeMemory(pThisObject->pCertEncoding);
    }

    pThisObject->pCertEncoding = 
        pCertificate->GetEncodedData
            (
                pCertificate,
                &pThisObject->uLength
            );

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
PKIEntitySetIssuedCert
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCertificate;
    PUCHAR                          pBackEncode  = pEncoding;
    ANSC_STATUS                     retStatus    = ANSC_STATUS_SUCCESS;

    if( hThisObject == NULL || pEncoding == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if(!AnscCheckAsn1Validity(pEncoding, length))
    {
        AnscTrace("Invalid ASN1 encoding.\n");

        return ANSC_ASN1_INVALID_ENCODE_LENGTH;
    }

    pCertificate = (PANSC_ASN1_CERTIFICATE)AnscAsn1CreateCertificate(NULL);

    if( pCertificate == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }
    
    /* decode the certificate */
    retStatus = pCertificate->DecodingData(pCertificate, (PVOID*)&pBackEncode);

    if( ANSC_STATUS_SUCCESS != retStatus)
    {
        pCertificate->AsnFree(pCertificate);

        goto EXIT;
    }

    if( pThisObject->hUserCert != NULL)
    {
        ((PANSC_ASN1_OBJECT)pThisObject->hUserCert)->AsnFree(pThisObject->hUserCert);
    }

    pThisObject->hUserCert = (ANSC_HANDLE)pCertificate;

    /* make a copy of the encoding */
    if( pThisObject->pCertEncoding != NULL)
    {
        AnscFreeMemory(pThisObject->pCertEncoding);
        pThisObject->uLength    = 0;
    }

    pThisObject->pCertEncoding = (PUCHAR)
        AnscAllocateMemory(length);

    if( pThisObject->pCertEncoding == NULL)
    {
        goto EXIT;
    }

    pThisObject->uLength       = length;

    AnscCopyMemory
        (
            pThisObject->pCertEncoding,
            pEncoding,
            length
        );

EXIT:

    return retStatus;
}

ANSC_STATUS
PKIEntitySetPrivateKeyInfo
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pPriKeyInfoEncode,
        ULONG                       length
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_PRIVATEKEYINFO       pKeyInfo     = NULL;
    PUCHAR                          pBack;
    ANSC_STATUS                     status;

    if(!AnscCheckAsn1Validity(pPriKeyInfoEncode, length))
    {
        AnscTrace("Invalid ASN1 encoding.\n");

        return ANSC_ASN1_INVALID_ENCODE_LENGTH;
    }

    /* decode the private key info */
    pBack = pPriKeyInfoEncode;

    pKeyInfo = (PANSC_ASN1_PRIVATEKEYINFO)AnscAsn1CreatePrivateKeyInfo(NULL);

    if( pKeyInfo == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    status = pKeyInfo->DecodingData(pKeyInfo, (PVOID*)&pBack);

    if( ANSC_STATUS_SUCCESS !=  status)
    {
        goto EXIT;
    }

    if( pThisObject->hKeyParam == NULL)
    {
        pThisObject->hKeyParam  = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
            AnscAllocateMemory(sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS));
    }

    status = 
        PKIUtilityInitKeyGenParams
            (
                pThisObject->hCryptoSSL,
                (PANSC_ASN1_CERTIFICATE)pThisObject->hUserCert,
                pKeyInfo,
                pThisObject->hKeyParam
            );

EXIT:

    /* free the key info */
    if( pKeyInfo != NULL)
    {
        pKeyInfo->AsnFree(pKeyInfo);
        pKeyInfo = NULL;
    }

    return status;
}

/**************************************************************
 *
 * Export the cert and private key info
 *
 * This function will create memory to holde the cert
 * and private key info encoding, the caller is responsible to 
 * free them.
 *
 *  If ppCertEncoding == NULL, cert encoding is not required;
 *  If ppPriKeyInfo   == NULL, priKeyInfo encoding is not required;
 *
 **************************************************************/
ANSC_STATUS
PKIEntityExportInfo
    (
        ANSC_HANDLE                 hThisObject,
        PVOID*                      ppCertEncoding,
        PULONG                      pLenOfCert,
        PVOID*                      ppPriKeyInfo,
        PULONG                      pLenOfKeyInfo
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PUCHAR                          pCertEncode  = NULL;
    PUCHAR                          pKeyEncode   = NULL;
    ULONG                           length       = 0;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* set the cert encoding first */
    if( ppCertEncoding != NULL)
    {
        if( pThisObject->pCertEncoding == NULL)
        {
            if( pThisObject->hUserCert != NULL)
            {
                pThisObject->pCertEncoding = 
                    ((PANSC_ASN1_CERTIFICATE)pThisObject->hUserCert)->
                        GetEncodedData
                            (
                                pThisObject->hUserCert,
                                &pThisObject->uLength
                            );
            }
        }

        if( pThisObject->pCertEncoding != NULL)
        {
            pCertEncode = (PUCHAR)AnscAllocateMemory(pThisObject->uLength);

            if( pCertEncode != NULL)
            {
                AnscCopyMemory
                    (
                        pCertEncode,
                        pThisObject->pCertEncoding,
                        pThisObject->uLength
                    );
            }
        }

        *ppCertEncoding = pCertEncode;

        if( pLenOfCert != NULL)
        {
            *pLenOfCert = pThisObject->uLength;
        }
    }

    /* set the key info */
    if( ppPriKeyInfo != NULL)
    {
        if( pThisObject->hKeyParam != NULL)
        {
            pKeyEncode = 
                PKIUtilityGetPrivateKeyInfoEncoding
                    (
                        pThisObject->hKeyParam,
                        pThisObject->GetKeyType(pThisObject),
                        &length
                    );
        }

        *ppPriKeyInfo = pKeyEncode;

        if( pLenOfKeyInfo != NULL)
        {
            *pLenOfKeyInfo = length;
        }
    }

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
PKIEntityExportToFile
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pCertFile,
        PCHAR                       pKeyInfoFile
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PUCHAR                          pCertEncoding= NULL;
    PUCHAR                          pKeyEncoding = NULL;
    ULONG                           certlength   = 0;
    ULONG                           keylength    = 0;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if( ANSC_STATUS_SUCCESS != 
            pThisObject->ExportInfo
                (
                    pThisObject,
                    (PVOID*)&pCertEncoding,
                    &certlength,
                    (PVOID*)&pKeyEncoding,
                    &keylength
                ))
    {
         return ANSC_STATUS_FAILURE;
    }

    if( pCertEncoding != NULL && pCertFile != NULL)
    {

        ASN1WriteBinaryToFile( pCertFile, pCertEncoding, certlength);

        AnscFreeMemory(pCertEncoding);
    }

    if( pKeyEncoding != NULL && pKeyInfoFile != NULL)
    {
        ASN1WriteBinaryToFile( pKeyInfoFile, pKeyEncoding, keylength);

        AnscFreeMemory(pKeyEncoding);
    }

    return ANSC_STATUS_SUCCESS;
}

/**********************************************************************
 *
 * Issue Certificate to user entity, if it's a CA;
 *
 **********************************************************************/
#if 0
static
ANSC_STATUS
asn1GetMD5FingerPrint
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hHashObject
    )
{
    PANSC_ASN1_OBJECT               pThisObject = (PANSC_ASN1_OBJECT)hThisObject;
    PANSC_CRYPTO_HASH               pHash       = (PANSC_CRYPTO_HASH)hHashObject;
    PANSC_CRYPTO_OBJECT             pCrypto     = NULL;
    PUCHAR                          pNewBuffer;
    ULONG                           length;
    ULONG                           ulHashSize;

    if( pThisObject == NULL || pHash == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    pCrypto = (PANSC_CRYPTO_OBJECT)AnscCreateCrypto(NULL);

    if (pCrypto == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    pNewBuffer = pThisObject->GetEncodedData(pThisObject, &length);

    if( pNewBuffer == NULL || length == 0)
    {
        pCrypto->Remove(pCrypto);

        return ANSC_STATUS_FAILURE;
    }

    pHash->Length = ANSC_MD5_OUTPUT_SIZE;

    ulHashSize  = pCrypto->Md5Digest(pNewBuffer, length, pHash);

    pHash->Length = ulHashSize;

    if( pNewBuffer != NULL)
    {
        AnscFreeMemory(pNewBuffer);
    }

    if( pCrypto != NULL)
    {
        pCrypto->Remove(pCrypto);
    }

    return ANSC_STATUS_SUCCESS;
}
#endif

ANSC_STATUS
PKIEntityIssueCert
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hUserObject,
        ULONG                       nYears,       /* Validity time */
        ULONG                       ulKeyUsage,
        BOOLEAN                     bAddSubKeyIdenExtension,
        BOOLEAN                     bIsCA,
        LONG                        pathLength
    )
{

    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PPKI_CLIENT_ENTITY              pUserObject  = (PPKI_CLIENT_ENTITY)hUserObject;
    PANSC_ASN1_CERTIFICATE          pCertificate = NULL;
    PANSC_ASN1_CERTIFICATE          pIssuerCert;
    PANSC_ASN1_NAME                 pNameObject;
    PANSC_ASN1_TIME                 pTimeHandle;
    PANSC_ASN1_INTEGER              pInteger;
    PANSC_ASN1_TBSCERTIFICATE       pTBSCert;
    PANSC_ASN1_VALIDITY             pValidity;
    ANSC_UNIVERSAL_TIME             curTime;
    PANSC_ASN1_SUBJECTPUBLICKEYINFO pPublicKeyInfo;
    ANSC_CRYPTO_PUB_KEY_GEN_PARAMS  genParams;
    PKI_KEY_TYPE                    keyType;
    ANSC_CRYPTO_HASH                hash;
    PANSC_ASN1_OBJECT               pKeyObject;
    PUCHAR                          pIdenBuf     = NULL;
    ULONG                           length;

    if( hThisObject == NULL || hUserObject == NULL || pThisObject->pCertAttr == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* no more than 20 years */
    if( nYears > 20)
    {
        nYears = 20;
    }

    /* create the certificate */
    pCertificate = (PANSC_ASN1_CERTIFICATE)
        AnscAsn1CreateCertificate(NULL);

    if( pCertificate == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* init the name */
    pNameObject = (PANSC_ASN1_NAME)pCertificate->GetIssuerHandle(pCertificate);
    pNameObject->InitAttribute(pNameObject, pThisObject->pCertAttr);

    pNameObject = (PANSC_ASN1_NAME)pCertificate->GetSubjectHandle(pCertificate);
    pNameObject->InitAttribute(pNameObject, pUserObject->pCertAttr);

    /* init other information */
    pTBSCert = (PANSC_ASN1_TBSCERTIFICATE)pCertificate->GetTbsCertificate(pCertificate);

    AnscAsn1GetCurrentTime((ANSC_HANDLE)&curTime);

    pValidity = (PANSC_ASN1_VALIDITY)pTBSCert->GetChildByIndex(pTBSCert, 4);

    /* not before */
    pTimeHandle = (PANSC_ASN1_TIME)pValidity->GetChildByIndex(pValidity, 0);
    pTimeHandle->SetTime(pTimeHandle, curTime);

    curTime.Year += (UINT)nYears;
    pTimeHandle = (PANSC_ASN1_TIME)pValidity->GetChildByIndex(pValidity, 1);
    pTimeHandle->SetTime(pTimeHandle, curTime);

    /*
     *  Set signature type
     */
    pCertificate->SetSignatureType(pCertificate, pUserObject->pCertAttr->SignAlgor);

    /*
     *  set public key
     */
    pUserObject->GetPublicKeyInfo(pUserObject,&keyType, &genParams);
    pPublicKeyInfo = (PANSC_ASN1_SUBJECTPUBLICKEYINFO)pCertificate->GetPublicKeyInfo(pCertificate);

    if( pPublicKeyInfo == NULL)
    {
        goto EXIT;
    }
    pPublicKeyInfo->GenerateKey
        (
            pPublicKeyInfo,
            keyType,
            &genParams
        );

    /*
     *  set the serial number, it supposed to be the MD5 fingerprint of public key 
     */
    pInteger       = (PANSC_ASN1_INTEGER)pCertificate->GetSerialNumber(pCertificate);
    pKeyObject     = (PANSC_ASN1_OBJECT)pPublicKeyInfo->GetExtraChild(pPublicKeyInfo);

    if( pKeyObject == NULL)
    {
        goto EXIT;
    }

    if( ANSC_STATUS_SUCCESS == 
            AnscAsn1GetMD5FingerPrint(pKeyObject, &hash))
    {
        /* make it as an unnegative value */
        if( hash.Value[0] > 0x80)
        {
           hash.Value[0] -= 0x80;
        }

        pInteger->SetStringValue
            (
                pInteger,
                hash.Value,
                hash.Length
            );
    }

    /*
     *  Add subjecAltName extension
     */
    if(AnscSizeOfString(pUserObject->pCertAttr->pSubjectAltName) > 0)
    {
        pCertificate->AddSubjectAltName
            (
                pCertificate,
                pUserObject->pCertAttr->GetSubjectAltName(pUserObject->pCertAttr)
            );
    }

    if( pUserObject->pCertAttr->hKB5PrinName != NULL)
    {
        pCertificate->AddKerberosSubAltName
            (
                pCertificate,
                pUserObject->pCertAttr->hKB5RealmName,
                pUserObject->pCertAttr->hKB5PrinName
            );
    }

    /*
     *  SubKeyIden extension is required;
     */
    if(bAddSubKeyIdenExtension)
    {
        pCertificate->AddSubjectKeyIdentifier(pCertificate);
    }

    pCertificate->AddKeyUsage(pCertificate, ulKeyUsage);

    if( bIsCA)
    {
        pCertificate->AddBasicConstraint(pCertificate, bIsCA, pathLength);
    }

    /*
     *  Set AuthorityKeyIdentifier 
     */
    pIssuerCert = (PANSC_ASN1_CERTIFICATE)pThisObject->hUserCert;
    
    if( pIssuerCert != NULL)
    {
        pIssuerCert->GetSubjectKeyIdentifier
            (
                pIssuerCert,
                (PUCHAR*)&pIdenBuf,
                &length
            );

        if( length > 0 && pIdenBuf != NULL)
        {
            pCertificate->AddAuthorityIdentifier
                (
                    pCertificate,
                    pIdenBuf,
                    length
                );

            AnscFreeMemory(pIdenBuf);
        }
    }

    /* sign it */
    if( pThisObject->hCryptAPI != NULL)
    {
        pCertificate->SignWithCryptAPI(pCertificate, pThisObject->hCryptAPI);
    }
    else
    {
        pCertificate->SignWithKeyParam
            (
                pCertificate, 
                pThisObject->GetKeyType(pThisObject),
                pThisObject->hKeyParam
            );
    }   

    /* set the cert */
    pUserObject->hUserCert = pCertificate;

    return ANSC_STATUS_SUCCESS;

EXIT:

    if( pCertificate != NULL)
    {
        pCertificate->AsnFree(pCertificate);
    }

    return ANSC_STATUS_FAILURE;
}

/**************************************************************
 * CryptoAPI functions
 **************************************************************/
PKI_KEY_TYPE
PKIEntityGetKeyType
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCert;
    PCRYPT_API_STRUCT               pCryptoAPI;

    if( hThisObject == NULL)
    {
        return PKI_RSA_KEY;
    }

    if( pThisObject->hCryptAPI != NULL)
    {
        pCryptoAPI = (PCRYPT_API_STRUCT)pThisObject->hCryptAPI;

        return pCryptoAPI->pGetKeyType(pCryptoAPI);
    }
    else if(pThisObject->pCertAttr != NULL)
    {
        return pThisObject->pCertAttr->KeyType;
    }
    else if( pThisObject->hUserCert == NULL)
    {
        return PKI_KEY_RESERVED;
    }

    pCert = (PANSC_ASN1_CERTIFICATE)
        pThisObject->hUserCert;

    return pCert->GetKeyType(pCert);
}

LONG
PKIEntityGetKeyLength
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PCRYPT_API_STRUCT               pCryptoAPI;
    PKI_KEY_TYPE                    keyType;
    PANSC_CRYPTO_PUB_KEY_GEN_PARAMS pGenParams;

    if( hThisObject == NULL)
    {
        return 0;
    }

    if( pThisObject->hCryptAPI != NULL)
    {
        pCryptoAPI = (PCRYPT_API_STRUCT)pThisObject->hCryptAPI;

        return pCryptoAPI->pGetKeyLength(pCryptoAPI);
    }
    else if(pThisObject->pCertAttr != NULL)
    {
        return pThisObject->pCertAttr->KeyLength;
    }

    keyType = pThisObject->GetKeyType(pThisObject);

    if( keyType == PKI_KEY_RESERVED)
    {
        return 0;
    }

    pGenParams = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
        pThisObject->hKeyParam;

    if( keyType == PKI_RSA_KEY)
    {
        return pGenParams->PrivateKey.RSA.Modulus.Length;
    }
    else if( keyType == PKI_DSA_KEY)
    {
        return pGenParams->PrivateKey.DSA.ParamX.Length;
    }

    return 0;
}

ANSC_STATUS
PKIEntityGetPublicKey
    (
        ANSC_HANDLE                 hThisObject,
        PPKI_KEY_TYPE               pKeyType,
        ANSC_HANDLE                 pKeyParam
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PCRYPT_API_STRUCT               pCryptoAPI;

    if( hThisObject == NULL || pKeyType == NULL || NULL == pKeyParam)
    {
        return ANSC_STATUS_FAILURE;
    }

    if( pThisObject->hCryptAPI == NULL)
    {
        *pKeyType = pThisObject->GetKeyType(pThisObject);

        AnscCopyMemory
            (
                pKeyParam,
                pThisObject->hKeyParam,
                sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
            );

        return ANSC_STATUS_SUCCESS;
    }
    else
    {
        pCryptoAPI = (PCRYPT_API_STRUCT)pThisObject->hCryptAPI;

        return 
            pCryptoAPI->pGetPublicKey
                (
                    pCryptoAPI,
                    pKeyType,
                    pKeyParam
                );
    }
}

ANSC_STATUS
PKIEntitySignData
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pDataWillBeSigned,
        ULONG                       lengthOfData,
        SIGNATURE_TYPE              SignatureType,
        PUCHAR                      pDataSigned,
        PULONG                      pLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PCRYPT_API_STRUCT               pCryptoAPI;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    ANSC_CRYPTO_PUB_KEY_PARAMS      params;
    PKI_KEY_TYPE                    keyType;
    int                             nHashMethod;
    PANSC_CRYPTO_PUB_KEY_GEN_PARAMS pGenParams;
    ANSC_STATUS                     retStatus;

    if( hThisObject == NULL || pDataWillBeSigned == NULL || pDataSigned == NULL || pLength == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if( pThisObject->hCryptAPI != NULL)
    {
        pCryptoAPI = (PCRYPT_API_STRUCT)pThisObject->hCryptAPI;

        return 
            pCryptoAPI->pSignData
                (
                    pCryptoAPI,
                    pDataWillBeSigned,
                    lengthOfData,
                    SignatureType,
                    pDataSigned,
                    pLength
                );
    }
    else
    {
        pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)pThisObject->hCryptoSSL;

        if( pSSLCrypto == NULL)
        {
            return ANSC_STATUS_FAILURE;
        }

        pGenParams = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
            pThisObject->hKeyParam;

        keyType = pThisObject->GetKeyType(pThisObject);

        if( keyType == PKI_RSA_KEY)
        {
            if( SignatureType == RSA_SHA1_SIGNATURE)
            {
                nHashMethod = RSA_SIGN_WITH_SHA1;
            }
            else if(SignatureType == RSA_MD5_SIGNATURE)
            {
                nHashMethod = RSA_SIGN_WITH_MD5;
            }
            else
            {
                return ANSC_STATUS_FAILURE;
            }
        }
        else if( keyType == PKI_DSA_KEY)
        {
            /* for DSA, it doesn't matter here, only SHA1 is supported */
            nHashMethod = 0;
        }
        else
        {
            return ANSC_STATUS_FAILURE;
        }

        /* init the params */
        if( keyType == PKI_RSA_KEY)
        {
            params.Key.RSA.RsaPrivateKey = pGenParams->PrivateKey.RSA;

            retStatus = 
                pSSLCrypto->RSAHashAndSign
                    (
                        nHashMethod,
                        (PVOID)pDataWillBeSigned,
                        lengthOfData,
                        (PVOID)pDataSigned,
                        pLength,
                        &params
                    );
        }
        else if( keyType == PKI_DSA_KEY)
        {
            params.Key.DSA.DsaPrivateKey = pGenParams->PrivateKey.DSA;

            retStatus = 
                pSSLCrypto->DSAHashAndSign
                    (
                        nHashMethod,
                        (PVOID)pDataWillBeSigned,
                        lengthOfData,
                        (PVOID)pDataSigned,
                        pLength,
                        &params
                    );
        }

        return retStatus;
    }
}

BOOLEAN
PKIEntityVerify
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pDataWillBeSigned,
        ULONG                       lengthOfData,
        SIGNATURE_TYPE              SignatureType,
        PUCHAR                      pSignature,
        ULONG                       signLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    ANSC_CRYPTO_PUB_KEY_PARAMS      params;
    PKI_KEY_TYPE                    keyType;
    ANSC_STATUS                     retStatus;
    ANSC_CRYPTO_PUB_KEY_GEN_PARAMS  genParams;
    UINT                            nHashMethod;

    if( hThisObject == NULL || pDataWillBeSigned == NULL || pSignature == NULL)
    {
        return FALSE;
    }

    /* get the public key info */
    pThisObject->GetPublicKeyInfo
        (
            pThisObject,
            &keyType,
            &genParams
        );

    pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)pThisObject->hCryptoSSL;

    if( pSSLCrypto == NULL)
    {
        return FALSE;
    }

    if( keyType == PKI_RSA_KEY)
    {
        if( SignatureType == RSA_SHA1_SIGNATURE)
        {
            nHashMethod = RSA_SIGN_WITH_SHA1;
        }
        else if(SignatureType == RSA_MD5_SIGNATURE)
        {
            nHashMethod = RSA_SIGN_WITH_MD5;
        }
        else
        {
            return FALSE;
        }
    }
    else if( keyType == PKI_DSA_KEY)
    {
        /* for DSA, it doesn't matter here, only SHA1 is supported */
        nHashMethod = 0;
    }
    else
    {
        return FALSE;
    }

    /* init the params */
    if( keyType == PKI_RSA_KEY)
    {
        params.Key.RSA.RsaPublicKey = genParams.PublicKey.RSA;

        retStatus = 
            pSSLCrypto->RSAHashAndVerify
                (
                    nHashMethod,
                    (PVOID)pDataWillBeSigned,
                    lengthOfData,
                    (PVOID)pSignature,
                    signLength,
                    &params
                );
    }
    else if( keyType == PKI_DSA_KEY)
    {
        params.Key.DSA.DsaPublicKey = genParams.PublicKey.DSA;

        retStatus = 
            pSSLCrypto->DSAHashAndVerify
                (
                    nHashMethod,
                    (PVOID)pDataWillBeSigned,
                    lengthOfData,
                    (PVOID)pSignature,
                    signLength,
                    &params
                );
    }

    return ( retStatus == ANSC_STATUS_SUCCESS);
}

ANSC_STATUS
PKIEntityDecryptData
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pDataWillBeDecrypted,
        ULONG                       lengthOfData,
        PUCHAR                      pDataDecrypted,
        PULONG                      pLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PCRYPT_API_STRUCT               pCryptoAPI;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    ANSC_CRYPTO_PUB_KEY_PARAMS      params;
    PKI_KEY_TYPE                    keyType;
    PANSC_CRYPTO_PUB_KEY_GEN_PARAMS pGenParams;
    ANSC_CRYPTO_PUB_ALGORITHM       Alg;
    ANSC_CRYPTO_PUB_OPERATION       Op;
    ANSC_STATUS                     retStatus;

    if( hThisObject == NULL || pDataWillBeDecrypted == NULL || pDataDecrypted == NULL || pLength == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if( pThisObject->hCryptAPI != NULL)
    {
        pCryptoAPI = (PCRYPT_API_STRUCT)pThisObject->hCryptAPI;

        return 
            pCryptoAPI->pDecryptData
                (
                    pCryptoAPI,
                    pDataWillBeDecrypted,
                    lengthOfData,
                    pDataDecrypted,
                    pLength
                );
    }
    else
    {
        keyType = pThisObject->GetKeyType(pThisObject);

        if( keyType != PKI_RSA_KEY)
        {
            return ANSC_STATUS_FAILURE;
        }

        pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)pThisObject->hCryptoSSL;

        if( pSSLCrypto == NULL)
        {
            return ANSC_STATUS_FAILURE;
        }

        pGenParams = (PANSC_CRYPTO_PUB_KEY_GEN_PARAMS)
            pThisObject->hKeyParam;

        keyType = pThisObject->GetKeyType(pThisObject);


        /* init the key */
        params.Key.RSA.RsaPrivateKey = *(&pGenParams->PrivateKey.RSA);

        /* init the decryption */
        Op  = ANSC_CRYPTO_PUB_OPERATION_DECRYPT;
        Alg = ANSC_CRYPTO_PUB_ALGORITHM_RSA_ENCRYPTION;

        params.InputSize  = lengthOfData;
        params.pInput     = (PVOID)pDataWillBeDecrypted;

        params.OutputSize = *pLength;
        params.pOutput    = (PVOID)pDataDecrypted;

        retStatus = 
            pSSLCrypto->Request
                (
                    Alg, 
                    Op, 
                    (ANSC_HANDLE)&params, 
                    NULL, 
                    NULL
                );

        if(pLength)
        {
            *pLength = params.OutputSize;
        }

        return retStatus;
    }
}

ANSC_STATUS
PKIEntityEncryptData
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pDataWillBeEncrypted,
        ULONG                       lengthOfData,
        PUCHAR                      pDataEncrypted,
        PULONG                      pLength
    )
{
    PPKI_CLIENT_ENTITY              pThisObject  = (PPKI_CLIENT_ENTITY)hThisObject;
    PANSC_CRYPTO_PUB_SSLEAY_OBJECT  pSSLCrypto   = NULL;
    ANSC_CRYPTO_PUB_KEY_PARAMS      params;
    PKI_KEY_TYPE                    keyType;
    ANSC_CRYPTO_PUB_ALGORITHM       Alg;
    ANSC_CRYPTO_PUB_OPERATION       Op;
    ANSC_STATUS                     retStatus;
    ANSC_CRYPTO_PUB_KEY_GEN_PARAMS  genParams;

    if( hThisObject == NULL || pDataWillBeEncrypted == NULL || pDataEncrypted == NULL || pLength == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* get the public key info */
    pThisObject->GetPublicKeyInfo
        (
            pThisObject,
            &keyType,
            &genParams
        );

    if( keyType != PKI_RSA_KEY)
    {
        return ANSC_STATUS_FAILURE;
    } 

    pSSLCrypto = (PANSC_CRYPTO_PUB_SSLEAY_OBJECT)pThisObject->hCryptoSSL;

    if( pSSLCrypto == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* init the key params */
    params.Key.RSA.RsaPublicKey = genParams.PublicKey.RSA;

    /* init the decryption */
    Op  = ANSC_CRYPTO_PUB_OPERATION_ENCRYPT;
    Alg = ANSC_CRYPTO_PUB_ALGORITHM_RSA_ENCRYPTION;

    params.InputSize  = lengthOfData;
    params.pInput     = (PVOID)pDataWillBeEncrypted;

    params.OutputSize = *pLength;
    params.pOutput    = (PVOID)pDataEncrypted;

    retStatus = 
        pSSLCrypto->Request
            (
                Alg, 
                Op, 
                (ANSC_HANDLE)&params, 
                NULL, 
                NULL
            );

    if(pLength)
    {
        *pLength = params.OutputSize;
    }

    return retStatus;
}

/**********************************************************************
 *
 * Get/Set name
 *
 **********************************************************************/
PCHAR
PKIEntityGetName
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PPKI_CLIENT_ENTITY              pThisObject = (PPKI_CLIENT_ENTITY)hThisObject;

    return pThisObject->pName;
}

ANSC_STATUS
PKIEntitySetName
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pString
    )
{
    PPKI_CLIENT_ENTITY              pThisObject = (PPKI_CLIENT_ENTITY)hThisObject;
    errno_t                         rc          = -1;

    if( pString == NULL)
    {
        AnscZeroMemory(pThisObject->pName, MAXI_ENTITY_NAME_BUFFER);
	return ANSC_STATUS_FAILURE;
    }

    /*CID: 69693 Dereference after null check*/
    if( AnscSizeOfString(pString) >= MAXI_ENTITY_NAME_BUFFER)
    {
        return ANSC_STATUS_FAILURE;
    }

    rc = strcpy_s(pThisObject->pName, sizeof(pThisObject->pName), pString);
    ERR_CHK(rc);

    return ANSC_STATUS_SUCCESS;
}

