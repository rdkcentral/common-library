/*
 * If not stated otherwise in this file or this component's Licenses.txt file the
 * following copyright and licenses apply:
 *
 * Copyright 2015 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**********************************************************************
   Copyright [2014] [Cisco Systems, Inc.]
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
**********************************************************************/

/**********************************************************************

    MODULE: alcert_base.c

        ASN.1 ANSC Code Generated by Cisco Systems, Inc.

    ---------------------------------------------------------------

    DESCRIPTION:

        This interface is for the ALCert implementation

        *   AnscCreateALCert
        *   AnscRemoveALCert

        *   ALCERTGetCACount
        *   ALCERTGetCACertByIndex
        *   ALCERTGetCAEntityByIndex
        *   ALCERTRemoveCAEntity
        *   ALCERTAddTrustedCA
        *   ALCERTAddCRL
        *   ALCERTAddSubjectWithCert
        *   ALCERTAddSubjectEntity
        *   ALCERTGetClientCount
        *   ALCERTGetClientByIndex
        *   ALCERTSetSubjectCert
        *   ALCERTRemoveClientEntity
        *   ALCERTRemoveCRL
        *   ALCERTRemoveAllCAs
        *   ALCERTRemoveAllClients
        *   ALCERTVerifyCertChain
        *   ALCERTSearchCAEntityByEncoding
        *   ALCERTSearchUserByEncoding
        *   ALCERTSearchCAByName
        *   ALCERTSearchEntityByName
        *   ALCERTAcquirePath
        *   ALCERTLookforIssuerEntity
        *   ALCERTGetCertChainPath
        *   ALCERTLookforCAInPath
        *   ALCERTLookforEntityWithIssuerName
        *   ALCERTLookforEntityWithKeyType
        *   ALCERTLookforEntityWithPubKey
        *   ALCERTVerifyCert
        *   ALCERTLoad
        *   ALCERTSave
        *   ALCERTGetCertStatus
        *   ALCERTUpdateCACrl

    ---------------------------------------------------------------

    ENVIRONMENT:

        platform independent

    ---------------------------------------------------------------

    AUTHOR:

        Bin Zhu

    ---------------------------------------------------------------

    REVISION HISTORY:

        *   09/15/2002  initial revision
        *   11/26/2003  add save/load functions;
        *   11/27/2003  add check cert status function;

 **********************************************************************/

#include "ansc_pki_local.h"
#include "alcert_global.h"
#include "cw_vpn_sakm.h"
#include "cert_status.h"
#include "cert_attr_structure.h"
#include "alcert_internal.h"

/**************************************************************
 *
 *  Exported APIs
 *
 ***************************************************************/
ANSC_HANDLE
AnscCreateALCert
    (
        ANSC_HANDLE                 hContainerContext,
        ANSC_HANDLE                 hReserved
    )
{
    PALCERT_CONTEXT                 pThisObject = NULL;
    
    if( hReserved != NULL)
    {
        pThisObject = (PALCERT_CONTEXT)
            AnscAllocateMemory((ULONG)hReserved);                   
    }
    else
    {
        pThisObject = (PALCERT_CONTEXT)
            AnscAllocateMemory((ULONG)sizeof(ALCERT_CONTEXT));
    }

    if( pThisObject == NULL)
    {
        return NULL;
    }

    /* init the parameters */
    pThisObject->hContainerContext  = hContainerContext;

    /* init the link list */
    AnscInitializeLock              (&pThisObject->CALock );
    AnscInitializeLock              (&pThisObject->ClientLock   );
    AnscSListInitializeHeader(&pThisObject->sCAList);
    AnscSListInitializeHeader(&pThisObject->sClientList);

    /* init the functions */
    pThisObject->Remove             = AnscRemoveALCert;
    pThisObject->GetCACount         = ALCERTGetCACount;
    pThisObject->GetCACertByIndex   = ALCERTGetCACertByIndex;
    pThisObject->GetCAEntityByIndex = ALCERTGetCAEntityByIndex;
    pThisObject->RemoveCAEntity     = ALCERTRemoveCAEntity;
    pThisObject->AddTrustedCA       = ALCERTAddTrustedCA;
    pThisObject->AddCRL             = ALCERTAddCRL;
    pThisObject->AddSubjectWithCert = ALCERTAddSubjectWithCert;
    pThisObject->AddSubjectEntity   = ALCERTAddSubjectEntity;
    pThisObject->GetClientCount     = ALCERTGetClientCount;
    pThisObject->GetClientByIndex   = ALCERTGetClientByIndex;
    pThisObject->SetSubjectCert     = ALCERTSetSubjectCert;
    pThisObject->RemoveClientEntity = ALCERTRemoveClientEntity;
    pThisObject->RemoveCRL          = ALCERTRemoveCRL;
    pThisObject->RemoveAllCAs       = ALCERTRemoveAllCAs;
    pThisObject->RemoveAllClients   = ALCERTRemoveAllClients;
    pThisObject->VerifyCertChain    = ALCERTVerifyCertChain;
    pThisObject->SearchCAEntityByEncoding
                                    = ALCERTSearchCAEntityByEncoding;
    pThisObject->SearchUserByEncoding
                                    = ALCERTSearchUserByEncoding;
    pThisObject->SearchCAByName     = ALCERTSearchCAByName;
    pThisObject->SearchEntityByName = ALCERTSearchEntityByName;
    pThisObject->AcquireCertPath    = ALCERTAcquirePath;
    pThisObject->LookforIssuerEntity= ALCERTLookforIssuerEntity;
    pThisObject->GetCertChainPath   = ALCERTGetCertChainPath;
    pThisObject->LookforCAInPath    = ALCERTLookforCAInPath;
    pThisObject->LookforEntityWithIssuerName
                                    = ALCERTLookforEntityWithIssuerName;
    pThisObject->LookforEntityWithKeyType
                                    = ALCERTLookforEntityWithKeyType;
    pThisObject->LookforEntityWithPubKey
                                    = ALCERTLookforEntityWithPubKey;
    pThisObject->VerifyUserCert     = ALCERTVerifyCert;
    pThisObject->Load               = ALCERTLoad;
    pThisObject->Save               = ALCERTSave;
    pThisObject->GetCertStatus      = ALCERTGetCertStatus;

    pThisObject->UpdateCACrl        = ALCERTUpdateCACrl;

    return pThisObject;
}


ANSC_STATUS
AnscRemoveALCert
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PALCERT_CONTEXT                 pThisObject = (PALCERT_CONTEXT)hThisObject;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    pThisObject->RemoveAllCAs(pThisObject);
    pThisObject->RemoveAllClients(pThisObject);

    AnscFreeLock(&pThisObject->ClientLock);
    AnscFreeLock(&pThisObject->CALock );

    AnscFreeMemory(hThisObject);

    return ANSC_STATUS_SUCCESS;
}

/**************************************************************
 *
 *  Other APIs
 *
 ***************************************************************/
#if 0
static ANSC_STATUS
removeIssuedCert
    (
        PALCERT_CONTEXT             pThisObject, 
        PCA_ENTITY                  pEntity
    )
{
    PANSC_ASN1_CERTIFICATE          pCACert, pUserCert;
    PSINGLE_LINK_ENTRY              pSListEntry;
    PPKI_CLIENT_ENTITY              pClientEntity;

    pCACert = (PANSC_ASN1_CERTIFICATE)pEntity->GetCertHandle(pEntity);

    if( pCACert == NULL)
    {
        return ANSC_STATUS_SUCCESS;
    }

    /* looking for the entry */
    AnscAcquireLock       (&pThisObject->ClientLock);
    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pClientEntity = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry   = AnscSListGetNextEntry(pSListEntry);

        if( pClientEntity != NULL)
        {
            pUserCert = (PANSC_ASN1_CERTIFICATE)pClientEntity->hUserCert;

            if( pUserCert != NULL && pUserCert->IsThisTheIssuer(pUserCert, pCACert))
            {
                pClientEntity->RemoveEntityCert(pClientEntity);
            }   
        }
    }

    AnscReleaseLock(&pThisObject->ClientLock);

    return ANSC_STATUS_SUCCESS;
}
#endif

ANSC_STATUS
ALCERTRemoveCAEntity
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hEntity,
        BOOLEAN                     bRovIssuedCert
    )
{
    UNREFERENCED_PARAMETER(bRovIssuedCert);
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PCA_ENTITY                      pEntity       = (PCA_ENTITY)hEntity;

    if( hThisObject == NULL || hEntity == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* looking for the entry */
    AnscAcquireLock       (&pThisObject->CALock);
    AnscSListPopEntryByLink(&pThisObject->sCAList, &pEntity->Linkage);
    AnscReleaseLock(&pThisObject->CALock);

    pEntity->Remove(pEntity);

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
ALCERTRemoveClientEntity
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hEntity
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity       = (PPKI_CLIENT_ENTITY)hEntity;

    if( hThisObject == NULL || hEntity == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* looking for the entry */
    AnscAcquireLock       (&pThisObject->ClientLock);
    AnscSListPopEntryByLink(&pThisObject->sClientList, &pEntity->Linkage);
    AnscReleaseLock(&pThisObject->ClientLock);

    pEntity->Remove(pEntity);

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
ALCERTRemoveCRL
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hEntity
    )
{
    UNREFERENCED_PARAMETER(hThisObject);
    PCA_ENTITY                      pEntity       = (PCA_ENTITY)hEntity;

    if( hEntity == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    return pEntity->RemoveCRL(pEntity);
}

/**************************************************************
 *  Get the total count of 
 ***************************************************************/
ULONG
ALCERTGetCACount
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;

    if( hThisObject == NULL)
    {
        return 0;
    }

    return AnscSListQueryDepth(&pThisObject->sCAList);
}

ULONG
ALCERTGetClientCount
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;

    if( hThisObject == NULL)
    {
        return 0;
    }

    return AnscSListQueryDepth(&pThisObject->sClientList);
}

/**************************************************************
 *  Get the CA cert with given index;
 **************************************************************/
ANSC_HANDLE
ALCERTGetCACertByIndex
    (
        ANSC_HANDLE                 hThisObject,
        ULONG                       ulIndex
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PCA_ENTITY                      pEntity;

    if( hThisObject == NULL)
    {
        return NULL;
    }


    pEntity = (PCA_ENTITY)
        pThisObject->GetCAEntityByIndex(pThisObject, ulIndex);

    if( pEntity == NULL)
    {
        return NULL;
    }

    return pEntity->hCertHandle;
}

ANSC_HANDLE
ALCERTGetCAEntityByIndex
    (
        ANSC_HANDLE                 hThisObject,
        ULONG                       ulIndex
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->CALock);

    pSListEntry = 
        AnscSListGetEntryByIndex
            (
                &pThisObject->sCAList,
                ulIndex
            );
    AnscReleaseLock(&pThisObject->CALock);

    if( pSListEntry == NULL)
    {
        return NULL;
    }

    return ACCESS_CA_ENTITY(pSListEntry);
}

ANSC_HANDLE
ALCERTGetClientByIndex
    (
        ANSC_HANDLE                 hThisObject,
        ULONG                       ulIndex
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->ClientLock);

    pSListEntry = 
        AnscSListGetEntryByIndex
            (
                &pThisObject->sClientList,
                ulIndex
            );

    AnscReleaseLock(&pThisObject->ClientLock);

    if( pSListEntry == NULL)
    {
        return NULL;
    }

    return ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
}

/**************************************************************
 * 
 * Add subject
 *
 **************************************************************/
ANSC_HANDLE
ALCERTAddSubjectWithCert
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pName,
        PUCHAR                      pCertEncoding,
        ULONG                       certLength,
        PUCHAR                      pKeyEncoding,
        ULONG                       keyLength
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pClientEntity;
    //PANSC_ASN1_CERTIFICATE          pCert;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    pClientEntity = (PPKI_CLIENT_ENTITY)
        AnscCreatePKIEntityWithCert
            (
                hThisObject,
                NULL,
                NULL,
                pCertEncoding,
                certLength,
                pKeyEncoding,
                keyLength
            );

    if( pClientEntity == NULL)
    {
        return NULL;
    }

    pClientEntity->SetName(pClientEntity, pName);
    /* verify it */
    pClientEntity->GetEntityCert(pClientEntity);
#if 0   
    if( pCert == NULL ||
        pThisObject->VerifyUserCert
            (
                pThisObject,
                pCert,
                1
            ) != ANSC_STATUS_SUCCESS)
    {
        AnscTrace("Failed to verify the user cert, please add the CA certificate first.\n");

        pClientEntity->Remove(pClientEntity);

        return NULL;
    }
#endif

    AnscAcquireLock(&pThisObject->ClientLock);

    AnscSListPushEntryAtBack(&pThisObject->sClientList, &pClientEntity->Linkage);

    AnscReleaseLock(&pThisObject->ClientLock);

    return pClientEntity;
}

ANSC_STATUS
ALCERTAddSubjectEntity
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hClientEntity
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pClientEntity = (PPKI_CLIENT_ENTITY)hClientEntity;

    if( hThisObject == NULL || hClientEntity == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    AnscAcquireLock(&pThisObject->ClientLock);

    AnscSListPushEntryAtBack(&pThisObject->sClientList, &pClientEntity->Linkage);

    AnscReleaseLock(&pThisObject->ClientLock);

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
ALCERTSetSubjectCert
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hClientEntity,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{
    PPKI_CLIENT_ENTITY              pClientEntity = (PPKI_CLIENT_ENTITY)hClientEntity;

    if( hThisObject == NULL || hClientEntity == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    return pClientEntity->SetIssuedCert(pClientEntity, pEncoding, length);
}

/**************************************************************
 * 
 * Add CA certificate
 *
 **************************************************************/
/* the CA Entity will be returned if succeded */
ANSC_HANDLE
ALCERTAddTrustedCA
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pName,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PCA_ENTITY                      pEntity;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    pEntity = (PCA_ENTITY)
        pThisObject->SearchCAEntityByEncoding
            (
                pThisObject,
                pEncoding,
                length
            );

    if( pEntity != NULL)
    {
        /* already there */
        /*
         *  DH  AL_CERT has to return failure if it is duplicate
         *
        return pEntity;
         */
        return  NULL;
    }

    /* create it and add to the list */
    pEntity = (PCA_ENTITY)
        AnscCreateCAEntityWithEncoding
            (
                pThisObject,
                NULL,
                pEncoding,
                length
            );

    if( pEntity == NULL)
    {
        return NULL;
    }

    pEntity->SetName(pEntity, pName);

    AnscAcquireLock(&pThisObject->CALock);

    AnscSListPushEntryAtBack(&pThisObject->sCAList, &pEntity->Linkage);

    AnscReleaseLock(&pThisObject->CALock);

    return pEntity;
}

ANSC_STATUS
ALCERTAddCRL
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCAEntity,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{
    PCA_ENTITY                      pCAEntity     = (PCA_ENTITY)hCAEntity;

    if( hThisObject == NULL || hCAEntity == NULL || pEncoding == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    return pCAEntity->SetCRLHandle(pCAEntity, pEncoding, length);
}

/**************************************************************
 * 
 * searching
 *
 **************************************************************/
ANSC_HANDLE
ALCERTSearchCAEntityByEncoding
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PCA_ENTITY                      pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->CALock);

    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sCAList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PCA_ENTITY)ACCESS_CA_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity->IsSameCert
                (
                    pEntity,
                    pEncoding,
                    length
                ))
        {
            AnscReleaseLock(&pThisObject->CALock);

            return pEntity;
        }              
    }

    AnscReleaseLock(&pThisObject->CALock);

    return NULL;
}

ANSC_HANDLE
ALCERTSearchUserByEncoding
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pEncoding,
        ULONG                       length
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->ClientLock);

    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity->pCertEncoding != NULL && pEntity->uLength == length)
        {
            if( AnscEqualMemory
                 (
                    pEntity->pCertEncoding,
                    pEncoding,
                    length
                 ))
            {
                AnscReleaseLock(&pThisObject->ClientLock);

                return pEntity;
            }
        }
    }

    AnscReleaseLock(&pThisObject->ClientLock);

    return NULL;
}

/**************************************************************
 * 
 * Operations 
 *
 **************************************************************/
ANSC_STATUS
ALCERTRemoveAllCAs
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PSINGLE_LINK_ENTRY              pSListEntry;
    PCA_ENTITY                      pEntity;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* free all the cas */
    AnscAcquireLock(&pThisObject->CALock);

    pSListEntry =   AnscSListPopEntry(&pThisObject->sCAList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PCA_ENTITY)ACCESS_CA_ENTITY(pSListEntry);
        pSListEntry = AnscSListPopEntry(&pThisObject->sCAList);

        if( pEntity != NULL)
        {
            pEntity->Remove(pEntity);
        }              
    }

    AnscReleaseLock(&pThisObject->CALock);


    /*
     *  reset the SList;
     */
    AnscSListInitializeHeader(&pThisObject->sCAList);      

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
ALCERTRemoveAllClients
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PSINGLE_LINK_ENTRY              pSListEntry;
    PPKI_CLIENT_ENTITY              pEntity;

    if( hThisObject == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* free all the client entities */

    AnscAcquireLock(&pThisObject->ClientLock);

    pSListEntry =   AnscSListPopEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry = AnscSListPopEntry(&pThisObject->sClientList);

        if( pEntity != NULL)
        {
            pEntity->Remove(pEntity);
        }              
    }

    AnscReleaseLock(&pThisObject->ClientLock);

    /*
     *  reset the SList;
     */
    AnscSListInitializeHeader(&pThisObject->sClientList);      

    return ANSC_STATUS_SUCCESS;
}

/**************************************************************
 * 
 * manage functions
 *
 **************************************************************/
ANSC_HANDLE
ALCERTLookforIssuerEntity
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCert
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCert         = (PANSC_ASN1_CERTIFICATE)hCert;
    PCA_ENTITY                      pEntity;
    PANSC_ASN1_CERTIFICATE          pCA;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL || hCert == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->CALock);

    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sCAList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PCA_ENTITY)ACCESS_CA_ENTITY(pSListEntry);

        if( pEntity != NULL)
        {
            pCA = (PANSC_ASN1_CERTIFICATE)pEntity->GetCertHandle(pEntity);

            if( pCert->IsThisTheIssuer(pCert, pCA))
            {
                AnscReleaseLock(&pThisObject->CALock);

                return pEntity;
            }
        }              

        pSListEntry = AnscSListGetNextEntry(pSListEntry);
    }

    AnscReleaseLock(&pThisObject->CALock);

    return NULL;

}

ANSC_STATUS
ALCERTVerifyCert
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCert,
        ULONG                       pathIndex
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCert         = (PANSC_ASN1_CERTIFICATE)hCert;
    PCA_ENTITY                      pEntity;
    ANSC_STATUS                     retStatus;

    if( hThisObject == NULL || hCert == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* looking for the issuer entity */
    pEntity = (PCA_ENTITY)
        pThisObject->LookforIssuerEntity
            (
                pThisObject,
                hCert
            );

    if( pEntity == NULL)
    {
        return ANSC_ASN1_ERROR_FIND_ISSUER;
    }

    /* verify the path, the path is zero based internally */
    retStatus = 
        pEntity->VerifyChild
            (
                pEntity,
                hCert,
                pathIndex - 1,
                FALSE
            );

    if( retStatus != ANSC_STATUS_SUCCESS)
    {
        return retStatus;
    }

    /* verify the issuer entity */
    pCert = (PANSC_ASN1_CERTIFICATE)
        pEntity->GetCertHandle(pEntity);

    if( pCert->IsSelfSigned(pCert))
    {
        return retStatus;
    }

    /* then try to find the issuer's CA and
     * verify the issuer we just founded
     */
    return
        pThisObject->VerifyUserCert
            (
                pThisObject,
                pCert,
                pathIndex + 1
            );
}

/**************************************************************
 * 
 * Verify
 *
 **************************************************************/
ANSC_STATUS 
RetrieveNameEncoding
    (
        PANSC_ASN1_CERTIFICATE      pCert,
        ANSC_HANDLE                 hSubjectID
    )
{
    PIKE_COMMON_ID                  pSubjectID = (PIKE_COMMON_ID)hSubjectID;
    ANSC_STATUS                     retStatus  = ANSC_STATUS_SUCCESS;
    ULONG                           length     = MAXIMUM_ID_SIZE;

    if( pCert == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if( pCert->IsRDNNameEmpty(pCert))
    {
        pSubjectID->IDType = ID_DER_ASN1_GN;
    }
    else
    {
        pSubjectID->IDType = ID_DER_ASN1_DN;
    }

    retStatus = 
        pCert->GetNameEncoding
            (
                pCert,
                pSubjectID->IDData,
                &length
            );

    if( retStatus == ANSC_STATUS_SUCCESS)
    {
        pSubjectID->IDSize = length;
    }

    return retStatus;
}

static
ANSC_STATUS 
verifySubjectID
    (
        PANSC_ASN1_CERTIFICATE      pCert,
        ANSC_HANDLE                 hSubjectID
    )
{
    PIKE_COMMON_ID                  pSubjectID = (PIKE_COMMON_ID)hSubjectID;
    ANSC_STATUS                     retStatus  = ANSC_STATUS_SUCCESS;
    PANSC_ASN1_NAME                 pNameObj;
    PUCHAR                          pEncoding;
    ULONG                           length;
    PANSC_ASN1_GENERALNAMES         pAltNames;
    UCHAR                           pValue[256]= { 0 };
    ULONG                           valueLen   = 256;
    ULONG                           typeMask;

    if( pCert == NULL || hSubjectID == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    if (pSubjectID->IDType == ID_DER_ASN1_DN)
    {
        CERT_TRACE("pSubjectID->IDType == ID_DER_ASN1_DN\n");

        /* check the DN name */
        pNameObj = (PANSC_ASN1_NAME)pCert->GetSubjectHandle(pCert);

        if( pNameObj == NULL)
        {
            return ANSC_STATUS_FAILURE;
        }

        pEncoding = pNameObj->GetEncodedData(pNameObj, &length);

        if( pEncoding == NULL || length == 0)
        {
            return ANSC_STATUS_FAILURE;
        }

        if (pSubjectID->IDSize != length)
        {
            retStatus = ANSC_STATUS_FAILURE;
        }
        else
        {
            if( !AnscEqualMemory
                    (
                        pSubjectID->IDData,
                        pEncoding,
                        length
                    ))
            {
                retStatus = ANSC_STATUS_FAILURE;
            }
        }

        AnscFreeMemory(pEncoding);

        return retStatus;
    }
    /* we handle these types currently */
    else if ( (pSubjectID->IDType == ID_IPV4_ADDR) || 
              (pSubjectID->IDType == ID_FQDN)      || 
              (pSubjectID->IDType == ID_USER_FQDN) )
    {
        pAltNames = (PANSC_ASN1_GENERALNAMES)
            pCert->GetSubjectAltName(pCert, TRUE);

        if( pAltNames == NULL)
        {
            CERT_TRACE("AL_CERT: No subjectAltNames in certificate.\n");
            return ANSC_STATUS_FAILURE;
        }

        if( pSubjectID->IDType == ID_IPV4_ADDR)
        {
            CERT_TRACE("pSubjectID->IDType == ID_IPV4_ADDR\n");

            typeMask = GENERALNAME_MASK_IPADDRESS;
        }
        else if( pSubjectID->IDType == ID_FQDN)
        {
            CERT_TRACE("pSubjectID->IDType == ID_FQDN\n");
            typeMask = GENERALNAME_MASK_DNSNAME;
        }
        else
        {
            CERT_TRACE("pSubjectID->IDType == ID_USER_FQDN\n");
            typeMask = GENERALNAME_MASK_RFC822NAME;
        }

        /* get the alt name */
        if( pAltNames->GetAltNameByMask
               (
                  pAltNames,
                  typeMask,
                  pValue,
                  &valueLen
               ) != ANSC_STATUS_SUCCESS)
        {
            return ANSC_STATUS_FAILURE;
        }

        if( valueLen != pSubjectID->IDSize ||
            !AnscEqualMemory
                (
                    pSubjectID->IDData,
                    pValue,
                    valueLen
                ))
        {
            return ANSC_STATUS_FAILURE;
        }

        return ANSC_STATUS_SUCCESS;
    }
    else
    {
        return ANSC_STATUS_FAILURE;
    }
}

/*
    BOOLEAN                     bCheckId
    TRUE  -- check the id again the certificate's subject 
             name or subjectAltName
    FALSE -- retrieve the subject name from the certificate
             and construct the id with it.
  */
ANSC_STATUS
ALCERTVerifyCertChain
    (
        ANSC_HANDLE                 hThisObject,
        ULONG                       ulCertPathLength,
        PVOID*                      pCertArray,
        PULONG                      pulCertSizeArray,
        ANSC_HANDLE                 pSubjectID,
        BOOLEAN                     bCheckID,        /* BAKEOF */
        BOOLEAN                     bCheckTime       /* Time is not required for KB5 */
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    ANSC_STATUS                     retStatus     = ANSC_STATUS_SUCCESS;
    PANSC_ASN1_CERTIFICATE          pCert         = NULL;
    PANSC_ASN1_CERTIFICATE          pIssuer       = NULL;
    PCA_ENTITY                      pEntity       = NULL;
    PANSC_ASN1_CERTIFICATE          pLastOne      = NULL;
    PIKE_COMMON_ID                  pCommonID     = (PIKE_COMMON_ID)pSubjectID;
    PAL_INTERNAL_CERTIFICATE        pInterCert    = NULL;
    PUCHAR                          pEncoding, pBack;
    ULONG                           i, length;
    PAL_INTERNAL_PUBLIC_KEY         inPublicKey;
    PAL_INTERNAL_PRIVATE_KEY        inPrivateKey;
    ANSC_CRYPTO_PUB_KEY_GEN_PARAMS  keyParam;
    PKI_KEY_TYPE                    keyType;

    AnscZeroMemory(&keyParam, sizeof(ANSC_CRYPTO_PUB_KEY_GEN_PARAMS));

    if( hThisObject == NULL || ulCertPathLength == 0 || pulCertSizeArray == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    /* check the cert chain one by one */
    for( i = 0; i < ulCertPathLength; i ++)
    {
        pEncoding = (PUCHAR)pCertArray[i];
        pBack     = pEncoding;
        length    = pulCertSizeArray[i];

        if(!AnscCheckAsn1Validity(pEncoding, length))
        {
            AnscTrace("Invalid ASN1 encoding.\n");

            retStatus = ANSC_ASN1_INVALID_ENCODE_LENGTH;

            goto EXIT;
        }

        pCert = (PANSC_ASN1_CERTIFICATE)AnscAsn1CreateCertificate(NULL);

        if( pCert == NULL)
        {
            retStatus = ANSC_STATUS_FAILURE;
            goto EXIT;
        }

        retStatus = pCert->DecodingData(pCert, (PVOID*)&pBack);

        if( retStatus != ANSC_STATUS_SUCCESS)
        {
            goto EXIT;
        }

        /* check the cert valid or not */
        retStatus = pCert->CheckValidity(pCert, bCheckTime);

        if( retStatus != ANSC_STATUS_SUCCESS)
        {
            goto EXIT;
        }
        
        if( i == 0)/* check the first one in the chain */
        {
            /* check it's selfsigned or not */
            if( pCert->IsSelfSigned(pCert))
            {
                /* look for it in the trusted CA list */
                pEntity = (PCA_ENTITY)
                    pThisObject->SearchCAEntityByEncoding
                        (
                            pThisObject,
                            pEncoding,
                            length
                        );

                if( pEntity == NULL)
                {
                    AnscTrace("The selfsigned root ca is not in the trusted list.\n");
                    retStatus = ANSC_ASN1_FAILED_TO_VERIFY;

                    goto EXIT;
                }
                else
                {
                    /* we don't need to verify the CA since we already did it when we added it. */
                }
            }
            else
            {
                retStatus = pThisObject->VerifyUserCert(pThisObject, pCert, ulCertPathLength);

                if( retStatus != ANSC_STATUS_SUCCESS)
                {
                    goto EXIT;
                }

                if( ulCertPathLength == 1) /* only one */
                {
                    pLastOne = pCert;
                }
            }

            /* remember this as an issuer */
            pIssuer = pCert;
            pCert   = NULL;
        }
        else 
        {
            retStatus = pIssuer->VerifyChildCert(pIssuer, pCert);

            if( retStatus != ANSC_STATUS_SUCCESS)
            {
                goto EXIT;
            }

            if( i == ulCertPathLength - 1) 
            {
                pLastOne = pCert;
            }

            /* remove the old issuer */
            pIssuer->AsnFree(pIssuer);

            /* remember this as an issuer */
            pIssuer = pCert;
            pCert   = NULL;
        }

        /* check the path valid or not */
        if( i != ulCertPathLength -1 &&
            pIssuer != NULL && !pIssuer->IsPathLengthValid(pIssuer, ulCertPathLength - i - 2))
            {
                retStatus = ANSC_STATUS_FAILURE;

                goto EXIT;
            }
    }

    /* we need to init or check some values here */
    if( pLastOne != NULL)
    {

        pCommonID->Attribute.AttributesMask |= CERTIFICATE_FLAG;

        /* get the key */
        pInterCert = (PAL_INTERNAL_CERTIFICATE)
            pCommonID->Attribute.hInternalCertificate;

        inPublicKey  = &pInterCert->PublicKey;
        inPrivateKey = &pInterCert->PrivateKey;
        keyType      = pLastOne->GetKeyType(pLastOne);

        pLastOne->ExportPublicKey
            (
                pLastOne,
                &keyParam
            );

        if( keyType == PKI_RSA_KEY)
        {
            pInterCert->KeyType           = RSA_KEY;
            inPublicKey->KeyType          = RSA_KEY;
            inPrivateKey->KeyType         = RSA_KEY;

            /* public key */
            AnscCopyMemory
                (
                    &inPublicKey->Key.RSAPublicKey,
                    &keyParam.PublicKey.RSA,
                    sizeof(AL_CRYPTO_RSA_PUBLIC_KEY)
                );

            /*
             *  DH  AL_CERT user requires keys in host order
             */
#if defined(_ANSC_LITTLE_ENDIAN_)
            AnscMemoryFromNToH((char*)inPublicKey->Key.RSAPublicKey.Modulus.Data,                  inPublicKey->Key.RSAPublicKey.Modulus.Length);
            AnscMemoryFromNToH((char*)inPublicKey->Key.RSAPublicKey.PublicExponent.Data.ucData,    inPublicKey->Key.RSAPublicKey.PublicExponent.Length);
#endif
        }
        else /* DSA */
        {
            pInterCert->KeyType           = DSA_KEY;
            inPublicKey->KeyType          = DSA_KEY;
            inPrivateKey->KeyType         = DSA_KEY;

            /* public key */
            AnscCopyMemory
                (
                    &inPublicKey->Key.DSAPublicKey,
                    &keyParam.PublicKey.DSA,
                    sizeof(AL_CRYPTO_DSA_PUBLIC_KEY)
                );

            /*
             *  DH  AL_CERT user requires keys in host order
             */
#if defined(_ANSC_LITTLE_ENDIAN_)
            AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamP.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamP.Length);
            AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamQ.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamQ.Length);
            AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamG.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamG.Length);
            AnscMemoryFromNToH((char*)inPublicKey->Key.DSAPublicKey.ParamY.Data.ucData,    inPublicKey->Key.DSAPublicKey.ParamY.Length);
#endif
        }

        if( bCheckID)
        {
            /* we need to do more to verify it */
            CERT_TRACE("AL_CERT: bCheckID == TRUE, verifySubjectID\n");
            retStatus = verifySubjectID(pLastOne, pSubjectID);
        }
        else
        {
            /* retrieve the name encoding */
            CERT_TRACE("AL_CERT: bCheckID == FALSE, RetrieveNameEncoding\n");

            retStatus = RetrieveNameEncoding(pLastOne, pSubjectID);
        }
    }

EXIT:

    if( pCert != NULL)
    {
        pCert->AsnFree(pCert);
    }

    if( pIssuer != NULL)
    {
        pIssuer->AsnFree(pIssuer);
    }

    return retStatus;
}

/**************************************************************
 * 
 * acquire the cert path
 *
 **************************************************************/
ANSC_STATUS
ALCERTAcquirePath
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hClientEntity,
        PULONG                      pulCertNumber,
        PVOID*                      pCertArray,
        PULONG                      pulCertSizeArray,
        BOOLEAN                     bIncludeRootCA
    )
{
    UNREFERENCED_PARAMETER(hThisObject);
    UNREFERENCED_PARAMETER(hClientEntity);
    UNREFERENCED_PARAMETER(pulCertNumber);
    UNREFERENCED_PARAMETER(pCertArray);
    UNREFERENCED_PARAMETER(pulCertSizeArray);
    UNREFERENCED_PARAMETER(bIncludeRootCA);

    return ANSC_STATUS_FAILURE;
}


/*************************************************************
 *
 *  Get the path length for certain subject entity;
 *
 *************************************************************/
ULONG
ALCERTGetCertChainPath
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hClientEntity
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity       = (PPKI_CLIENT_ENTITY)hClientEntity;
    ULONG                           pathLength    = 1;
    PANSC_ASN1_CERTIFICATE          pCert;
    PCA_ENTITY                      pCA;

    if( hThisObject == NULL || hClientEntity == NULL)
    {
        return 0;
    }

    pCert = (PANSC_ASN1_CERTIFICATE)pEntity->hUserCert;

    if( pCert == NULL)
    {
        return 0;
    }

    /* looking for the issuer */
    while( !pCert->IsSelfSigned(pCert))
    {
        pCA = (PCA_ENTITY)
            pThisObject->LookforIssuerEntity
                (
                    pThisObject,
                    pCert
                );

        if( pCA == NULL)
        {
            AnscTrace("Failed to find the root CA.\n");
            return 0;
        }

        pathLength ++;
        pCert = (PANSC_ASN1_CERTIFICATE)pCA->hCertHandle;

        if( pCert == NULL)
        {
            return 0;
        }
    }
 
    return pathLength;
}

/*************************************************************
 *
 *  Get the CA entity in the certain index of cert chain
 *
 *  ulIndex == 0 will be the cert of the client entity, the last
 *  one will be the selfsigned root ca.
 *
 *************************************************************/
ANSC_HANDLE
ALCERTLookforCAInPath
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hClientEntity,
        UINT                        ulIndex
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity       = (PPKI_CLIENT_ENTITY)hClientEntity;
    ULONG                           index         = 0;
    PANSC_ASN1_CERTIFICATE          pCert;
    PCA_ENTITY                      pCA;

    if( hThisObject == NULL || hClientEntity == NULL)
    {
        return NULL;
    }

    if( ulIndex == 0)
    {
        return NULL;
    }

    pCert = (PANSC_ASN1_CERTIFICATE)pEntity->hUserCert;

    if( pCert == NULL)
    {
        return NULL;
    }

    while(!pCert->IsSelfSigned(pCert))
    {
        index ++;

        pCA = (PCA_ENTITY)
            pThisObject->LookforIssuerEntity
                (
                    pThisObject,
                    pCert
                );

        if( index == ulIndex || pCA == NULL)
        {
            return pCA;
        }

        /* look for the next one */
        pCert = (PANSC_ASN1_CERTIFICATE)pCA->hCertHandle;
    }

    return NULL;
}

/*************************************************************
 *
 *  Search for the subject entity with the given issuer name
 *
 *************************************************************/
ANSC_HANDLE
ALCERTLookforEntityWithIssuerName
    (
        ANSC_HANDLE                 hThisObject,
        PUCHAR                      pIssuerEncoding,
        ULONG                       length
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;
    PANSC_ASN1_CERTIFICATE          pCert;
    PANSC_ASN1_NAME                 pIssuerName;
    PUCHAR                          pEncoding;
    ULONG                           encLength;

    if( hThisObject == NULL || pIssuerEncoding == NULL)
    {
        return NULL;
    }

    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity != NULL)
        {
            pCert = (PANSC_ASN1_CERTIFICATE)pEntity->hUserCert;

            if( pCert != NULL)
            {
                pIssuerName = (PANSC_ASN1_NAME)pCert->GetIssuerHandle(pCert);

                if( pIssuerName != NULL)
                {
                    pEncoding = pIssuerName->GetEncodedData(pIssuerName, &encLength);

                    if( pEncoding != NULL   &&
                        encLength == length &&
                        AnscEqualMemory
                            (
                                pEncoding,
                                pIssuerEncoding,
                                length
                            ))
                    {
                        AnscFreeMemory(pEncoding);
                        return pEntity;
                    }

                    if( pEncoding != NULL)
                    {
                        AnscFreeMemory(pEncoding);
                    }
                }
            }
        }
    }

    return NULL;
}

/*************************************************************
 *
 *  Search for the subject entity with key type
 *
 *************************************************************/
ANSC_HANDLE
ALCERTLookforEntityWithKeyType
    (
        ANSC_HANDLE                 hThisObject,
        PKI_KEY_TYPE                keyType
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;
    PANSC_ASN1_CERTIFICATE          pCert;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->ClientLock);
    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity != NULL)
        {
            pCert = (PANSC_ASN1_CERTIFICATE)pEntity->hUserCert;

            if( pCert != NULL && pCert->GetKeyType(pCert) == keyType)
            {
                AnscReleaseLock(&pThisObject->ClientLock);

                return pEntity;
            }
        }
    }

    AnscReleaseLock(&pThisObject->ClientLock);

    return NULL;
}

/*************************************************************
 *
 *  Search for the subject entity with the same pub key
 *
 *************************************************************/
ANSC_HANDLE
ALCERTLookforEntityWithPubKey
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCert
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCert         = (PANSC_ASN1_CERTIFICATE)hCert;
    PPKI_CLIENT_ENTITY              pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->ClientLock);
    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity != NULL)
        {
            if(pCert->IsKeyMatching
                    (
                        pCert,
                        pEntity->GetKeyType(pEntity),
                        pEntity->hKeyParam
                    ))
            {
                AnscReleaseLock(&pThisObject->ClientLock);

                return pEntity;
            }
        }
    }

    AnscReleaseLock(&pThisObject->ClientLock);

    return NULL;
}


ANSC_HANDLE
ALCERTSearchCAByName
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pName
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PCA_ENTITY                      pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->CALock);
    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sCAList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PCA_ENTITY)ACCESS_CA_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity != NULL)
        {
            if(strcmp(pName, pEntity->GetName(pEntity)) == 0 )
            {
                AnscReleaseLock(&pThisObject->CALock);

                return pEntity;
            }
        }
    }

    AnscReleaseLock(&pThisObject->CALock);

    return NULL;
}

ANSC_HANDLE
ALCERTSearchEntityByName
    (
        ANSC_HANDLE                 hThisObject,
        PCHAR                       pName
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PPKI_CLIENT_ENTITY              pEntity;
    PSINGLE_LINK_ENTRY              pSListEntry;

    if( hThisObject == NULL)
    {
        return NULL;
    }

    AnscAcquireLock(&pThisObject->ClientLock);
    pSListEntry =   AnscSListGetFirstEntry(&pThisObject->sClientList);

    while( pSListEntry != NULL)
    {
        pEntity     = (PPKI_CLIENT_ENTITY)ACCESS_PKI_CLIENT_ENTITY(pSListEntry);
        pSListEntry = AnscSListGetNextEntry(pSListEntry);

        if( pEntity != NULL)
        {
            if( strcmp(pName, pEntity->GetName(pEntity)) == 0 )
            {
                AnscReleaseLock(&pThisObject->ClientLock);

                return pEntity;
            }
        }
    }

    AnscReleaseLock(&pThisObject->ClientLock);

    return NULL;
}

/*************************************************************
 *
 *  Load/Save functions;
 *
 *************************************************************/
ANSC_STATUS
ALCERTLoad
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hSysStorage
    )
{
    if( hThisObject == NULL || hSysStorage == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    return ANSC_STATUS_SUCCESS;
}

ANSC_STATUS
ALCERTSave
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hSysStorage
    )
{
    
    if( hThisObject == NULL || hSysStorage == NULL)
    {
        return ANSC_STATUS_FAILURE;
    }

    return ANSC_STATUS_SUCCESS;
}

/*************************************************************
 *
 *  Check Certificate Status
 *
 *************************************************************/
ULONG
ALCERTGetCertStatus
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCertHandle
    )
{
    PALCERT_CONTEXT                 pThisObject   = (PALCERT_CONTEXT)hThisObject;
    PANSC_ASN1_CERTIFICATE          pCert         = (PANSC_ASN1_CERTIFICATE)hCertHandle;
    ULONG                           uStatus;
    PCA_ENTITY                      pEntity;
    ANSC_STATUS                     status;

    uStatus = pCert->CheckTime(pCert);

    if( uStatus > CERT_VALID)
    {
        return uStatus;
    }

    /* check if it's selfsigned or not */
    if( pCert->IsSelfSigned(pCert))
    {
        if( pCert->VerifySignature(pCert, NULL))
        {
            return CERT_VALID;
        }

        return CERT_VERIFY_FAILURE;
    }

    /* look for the issuer */
    pEntity = (PCA_ENTITY)pThisObject->LookforIssuerEntity(pThisObject, hCertHandle);

    if( pEntity == NULL)
    {
        return CERT_NO_CA;
    }

    status = pEntity->VerifyChild(pEntity, hCertHandle, 0, FALSE);

    if( status == ANSC_ASN1_CERT_REVOKED)
    {
        return CERT_REVOKED;
    }
    else if( status != ANSC_STATUS_SUCCESS)
    {
        return CERT_VERIFY_FAILURE;
    }

    return CERT_VALID;
}

/*************************************************************
 *
 *  Online get the ca's crl
 *
 *************************************************************/
ANSC_STATUS
ALCERTUpdateCACrl
    (
        ANSC_HANDLE                 hThisObject,
        ANSC_HANDLE                 hCAHandle
    )
{
    UNREFERENCED_PARAMETER(hThisObject);
    UNREFERENCED_PARAMETER(hCAHandle);

    return ANSC_STATUS_SUCCESS;
}
